<!doctype html>
<html lang="en-us">
  <head>
    <title>Data over QR with Audio Backchannel</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
        line-height: 1.5;
        -webkit-text-size-adjust: 100%;
        -webkit-font-smoothing: antialiased;
      }

      .app {
        max-width: 800px;
        margin: 0 auto;
        padding: 24px 16px;
      }

      .title {
        font-size: 24px;
        font-weight: 600;
        text-align: center;
        margin-bottom: 24px;
        color: #000;
      }

      .tabs {
        display: flex;
        gap: 8px;
        margin-bottom: 24px;
      }

      .tab {
        flex: 1;
        padding: 12px;
        font-size: 14px;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: #000;
        background: none;
        border: 1px solid #000;
        cursor: pointer;
      }

      .tab.active {
        background: #000;
        color: #fff;
      }

      .panel {
        display: none;
        border: 1px solid #000;
        padding: 24px;
      }

      .panel.active {
        display: block;
      }

      /* QR Code */
      .qr-container {
        width: 100%;
        max-width: 600px;
        aspect-ratio: 1;
        margin: 0 auto 24px;
        background: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #qrcode {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 16px;
      }

      #qrcode canvas {
        width: 100% !important;
        height: 100% !important;
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
      }

      /* Camera */
      .camera-container {
        width: 100%;
        max-width: 600px;
        aspect-ratio: 4/3;
        margin: 0 auto 24px;
        background: #000;
        position: relative;
        overflow: hidden;
      }

      #video {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .camera-overlay {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.5);
        color: #fff;
        font-weight: 500;
        cursor: pointer;
      }

      .camera-active .camera-overlay {
        display: none;
      }

      /* Text Areas */
      .text-container {
        margin-bottom: 24px;
      }

      .text-label {
        display: block;
        font-size: 14px;
        font-weight: 500;
        margin-bottom: 8px;
        color: #000;
      }

      .text-area {
        width: 100%;
        height: 120px;
        padding: 12px;
        font-family: inherit;
        font-size: 14px;
        line-height: 1.5;
        border: 1px solid #000;
        background: none;
        resize: none;
      }

      .text-area:focus {
        outline: none;
        border-color: #000;
      }

      /* Progress */
      .progress-container {
        margin-bottom: 24px;
      }

      .progress-bar {
        height: 40px;
        background: #f5f5f5;
        border: 1px solid #000;
        position: relative;
        overflow: hidden;
      }

      .progress-segment {
        position: absolute;
        top: 0;
        height: 100%;
        background: #000;
        transition:
          left 0.2s ease,
          width 0.2s ease;
      }

      .progress-text {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #fff;
        font-weight: 500;
        mix-blend-mode: difference;
        pointer-events: none;
        z-index: 1;
      }

      .progress-bar.complete .progress-segment {
        background: #4caf50;
      }

      /* Logs */
      .log {
        height: 120px;
        padding: 12px;
        border: 1px solid #000;
        font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
        font-size: 12px;
        line-height: 1.4;
        overflow-y: auto;
        white-space: pre-wrap;
        background: #fafafa;
      }

      .log-entry {
        margin-bottom: 4px;
        padding: 4px 8px;
        border-radius: 2px;
      }

      .log-entry[data-type='chunk'] {
        border-left: 3px solid #2196f3;
        background: #e3f2fd;
      }

      .log-entry[data-type='info'] {
        border-left: 3px solid #0070f3;
        background: #f5f9ff;
      }

      .log-entry[data-type='error'] {
        border-left: 3px solid #f44336;
        background: #ffebee;
      }

      .log-entry[data-type='success'] {
        border-left: 3px solid #4caf50;
        background: #e8f5e9;
      }

      .log-entry[data-direction='outgoing'] {
        opacity: 0.8;
      }

      /* Mobile */
      @media (max-width: 768px) {
        .app {
          padding: 16px;
        }

        .title {
          padding: 0 16px;
        }

        .tabs {
          padding: 0 16px;
        }

        .panel {
          padding: 0;
          border: none;
        }

        .qr-container {
          width: 100%;
          max-width: none;
          margin: 0 0 24px;
        }

        .camera-container {
          width: 100%;
          max-width: none;
          aspect-ratio: 1;
          margin: 0 0 24px;
        }

        .text-container,
        .progress-container,
        .log {
          margin: 0 0 24px;
        }

        .text-area {
          height: 160px;
        }

        .log {
          height: 160px;
        }
      }

      #canvas {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="app">
      <h1 class="title">Data over QR with Audio Backchannel</h1>

      <div class="tabs">
        <button class="tab active" id="sendTab">Send Data</button>
        <button class="tab" id="receiveTab">Receive Data</button>
      </div>

      <div class="panel active" id="sendPanel">
        <div class="qr-container">
          <div id="qrcode"></div>
        </div>

        <div class="text-container">
          <label class="text-label">Message to Send</label>
          <textarea class="text-area" id="txData">Hello from Folk Canvas!</textarea>
          <div id="chunkInfo" style="font-size: 12px; margin-top: 4px; color: #666"></div>
        </div>

        <div class="progress-container">
          <label class="text-label">Acknowledged Chunks</label>
          <div class="progress-bar" id="senderProgressBar">
            <div class="progress-text" id="senderProgressText">0%</div>
          </div>
          <div id="senderThroughput" style="font-size: 12px; margin-top: 4px; color: #666"></div>
        </div>

        <div class="log" id="sendLog"></div>
      </div>

      <div class="panel" id="receivePanel">
        <div class="camera-container" id="cameraContainer">
          <video id="video" playsinline></video>
          <div class="camera-overlay" id="cameraOverlay">Start Camera</div>
        </div>

        <div class="progress-container">
          <label class="text-label">Receiving Progress</label>
          <div class="progress-bar" id="progressBar">
            <div class="progress-text" id="progressText">0%</div>
          </div>
          <div id="receiverThroughput" style="font-size: 12px; margin-top: 4px; color: #666"></div>
        </div>

        <div class="text-container">
          <label class="text-label">Received Data</label>
          <textarea class="text-area" id="receivedText" readonly></textarea>
        </div>

        <div class="log" id="receiveLog"></div>
      </div>
    </div>

    <canvas id="canvas"></canvas>

    <!-- QR Code libraries -->
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>

    <!-- Import QRTPB and FolkAudioWave modules -->
    <script type="module">
      import { QRTPB } from '@labs/QRTPB.ts';
      import { FolkAudioWave } from '@labs/folk-audio-wave.ts';

      // DOM elements
      const sendTab = document.getElementById('sendTab');
      const receiveTab = document.getElementById('receiveTab');
      const sendPanel = document.getElementById('sendPanel');
      const receivePanel = document.getElementById('receivePanel');
      const txData = document.getElementById('txData');
      const qrcode = document.getElementById('qrcode');
      const video = document.getElementById('video');
      const canvas = document.getElementById('canvas');
      const cameraContainer = document.getElementById('cameraContainer');
      const cameraOverlay = document.getElementById('cameraOverlay');
      const sendLog = document.getElementById('sendLog');
      const receiveLog = document.getElementById('receiveLog');
      const progressText = document.getElementById('progressText');
      const receivedText = document.getElementById('receivedText');

      // Video scanning state
      let videoStream = null;
      let scanInterval = null;
      const canvasContext = canvas.getContext('2d');

      // Create QRTPB instance
      const qrtpb = new QRTPB(
        (direction, type, message, data) => {
          // Create log entry
          const entry = document.createElement('div');
          entry.className = 'log-entry';

          // Convert chunk-related messages to use chunk type
          if (message.includes('chunk') || message.includes('Chunk')) {
            entry.dataset.type = 'chunk';
          } else {
            entry.dataset.type = type;
          }

          entry.dataset.direction = direction;

          const timestamp = new Date().toLocaleTimeString();
          let text = `[${timestamp}] ${message}`;
          if (data) text += `\n${data}`;

          entry.textContent = text;

          // Add to appropriate log based on current mode
          const log = qrtpb.getMode() === 'send' ? sendLog : receiveLog;
          log.appendChild(entry);
          log.scrollTop = log.scrollHeight;

          // If this is a success message about completion, update UI
          if (type === 'success' && message.includes('DONE')) {
            // Only stop audio if we're receiving the DONE signal, not sending it
            if (message.includes('Received DONE signal from sender')) {
              // Stop audio backchannel permanently
              audioWave.stopListening();
              audioWave.dispose();
              isAudioInitialized = false;
            }
          }
        },
        (state) => {
          if (state.mode === 'send') {
            generateQRCode();

            // Update sender progress visualization
            const senderProgressBar = document.getElementById('senderProgressBar');
            const senderProgressText = document.getElementById('senderProgressText');
            const senderThroughput = document.getElementById('senderThroughput');

            // Clear existing segments
            senderProgressBar.querySelectorAll('.progress-segment').forEach((segment) => segment.remove());

            if (state.excludedRanges && state.excludedRanges.length > 0 && state.totalLength > 0) {
              // Calculate total percentage for progress text
              let totalAcknowledged = 0;
              state.excludedRanges.forEach(([start, end]) => {
                totalAcknowledged += end - start + 1;
              });
              const percentage = Math.round((totalAcknowledged / state.totalLength) * 100) || 0;
              senderProgressText.textContent = `${percentage}%`;

              // Calculate throughput
              const now = Date.now();
              if (!window.senderStartTime) {
                window.senderStartTime = now;
                window.lastAcknowledged = 0;
              }
              const elapsedSeconds = (now - window.senderStartTime) / 1000;
              const bytesPerSecond = Math.round(totalAcknowledged / elapsedSeconds);
              senderThroughput.textContent = `${bytesPerSecond} bytes/sec`;

              // Create segments for each acknowledged range
              state.excludedRanges.forEach(([start, end]) => {
                const segment = document.createElement('div');
                segment.className = 'progress-segment';

                // Calculate position and width as percentages
                const left = (start / state.totalLength) * 100;
                const width = ((end - start + 1) / state.totalLength) * 100;

                segment.style.left = `${left}%`;
                segment.style.width = `${width}%`;

                // Add a tooltip showing the range
                segment.title = `Characters ${start}-${end}`;

                senderProgressBar.appendChild(segment);
              });

              // Add/remove complete class
              if (percentage === 100) {
                senderProgressBar.classList.add('complete');
              } else {
                senderProgressBar.classList.remove('complete');
              }
            } else {
              senderProgressText.textContent = '0%';
              senderProgressBar.classList.remove('complete');
              senderThroughput.textContent = '';
            }
          } else {
            // Update received text
            receivedText.value = state.receivedText || '';

            // Update progress visualization
            const progressBar = document.getElementById('progressBar');
            const receiverThroughput = document.getElementById('receiverThroughput');

            // Clear existing segments
            progressBar.querySelectorAll('.progress-segment').forEach((segment) => segment.remove());

            if (state.maxSeenIndex > 0) {
              // Calculate total percentage for progress text
              let totalReceived = 0;
              state.receivedRanges.forEach(([start, end]) => {
                totalReceived += end - start + 1;
              });
              const percentage = Math.round((totalReceived / (state.maxSeenIndex + 1)) * 100);
              progressText.textContent = `${percentage}%`;

              // Calculate throughput
              const now = Date.now();
              if (!window.receiverStartTime) {
                window.receiverStartTime = now;
                window.lastReceived = 0;
              }
              const elapsedSeconds = (now - window.receiverStartTime) / 1000;
              const bytesPerSecond = Math.round(totalReceived / elapsedSeconds);
              receiverThroughput.textContent = `${bytesPerSecond} bytes/sec`;

              // Create segments for each range
              state.receivedRanges.forEach(([start, end]) => {
                const segment = document.createElement('div');
                segment.className = 'progress-segment';

                // Calculate position and width as percentages
                const left = (start / (state.maxSeenIndex + 1)) * 100;
                const width = ((end - start + 1) / (state.maxSeenIndex + 1)) * 100;

                segment.style.left = `${left}%`;
                segment.style.width = `${width}%`;

                progressBar.appendChild(segment);
              });

              // Add/remove complete class
              if (percentage === 100) {
                progressBar.classList.add('complete');
              } else {
                progressBar.classList.remove('complete');
              }
            } else {
              progressText.textContent = '0%';
              progressBar.classList.remove('complete');
              receiverThroughput.textContent = '';
            }
          }
        },
      );

      // Create FolkAudioWave instance
      const audioWave = new FolkAudioWave();
      let audioWaveReady = false;

      // Audio backchannel state
      let isAudioInitialized = false;

      // Initialize audio backchannel
      const initAudioBackchannel = async () => {
        if (isAudioInitialized) return;

        // Wait for FolkAudioWave to be ready
        if (!audioWaveReady) {
          await audioWave.ready();
          audioWaveReady = true;
        }

        // Start listening in both modes
        await audioWave.startListening((data) => {
          // Process received backchannel message
          qrtpb.processBackchannelMessage(data);
        });

        // Start backchannel update loop
        const sendBackchannelUpdates = async () => {
          if (qrtpb.getMode() === 'receive') {
            const message = qrtpb.getBackchannelMessage();
            if (message) {
              try {
                // Increased volume from 20 to 50
                await audioWave.send(message, 50);
              } catch (e) {
                console.error('Failed to send backchannel message:', e);
              }
            }
          }
          // Schedule next update if audio is still initialized
          if (isAudioInitialized) {
            setTimeout(sendBackchannelUpdates, 100); // Small delay between attempts
          }
        };

        // Start the update loop
        sendBackchannelUpdates();
        isAudioInitialized = true;
      };

      // Generate QR code
      const generateQRCode = () => {
        qrcode.innerHTML = '';
        const data = qrtpb.getCurrentQRCodeData();
        if (!data) return;

        const canvas = document.createElement('canvas');
        qrcode.appendChild(canvas);

        // Calculate size based on container width
        const containerWidth = qrcode.clientWidth;
        const size = Math.min(containerWidth, 600);

        QRCode.toCanvas(canvas, data, {
          width: size,
          height: size,
          margin: 0,
          color: { dark: '#000', light: '#fff' },
        });
      };

      // Camera control functions
      const startCamera = () => {
        if (!navigator.mediaDevices?.getUserMedia) return;

        const constraints = {
          video: {
            facingMode: { exact: 'environment' },
            width: { min: 640, ideal: 1280, max: 1920 },
            height: { min: 640, ideal: 1280, max: 1920 },
            aspectRatio: window.innerWidth <= 768 ? 1 : 1.33333,
          },
        };

        navigator.mediaDevices
          .getUserMedia(constraints)
          .catch(() => navigator.mediaDevices.getUserMedia({ video: true }))
          .then((stream) => {
            videoStream = stream;
            video.srcObject = stream;
            video.setAttribute('playsinline', true);
            video.play();

            scanInterval = setInterval(scanQRCode, 100);
            cameraContainer.classList.add('camera-active');
          })
          .catch((error) => console.error('Camera error:', error));
      };

      const stopCamera = () => {
        if (videoStream) {
          videoStream.getTracks().forEach((track) => track.stop());
          videoStream = null;
        }
        if (scanInterval) {
          clearInterval(scanInterval);
          scanInterval = null;
        }
        cameraContainer.classList.remove('camera-active');
      };

      // QR code scanning function
      const scanQRCode = () => {
        if (video.readyState !== video.HAVE_ENOUGH_DATA) return;

        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        canvasContext.drawImage(video, 0, 0);

        const imageData = canvasContext.getImageData(0, 0, canvas.width, canvas.height);
        const code = jsQR(imageData.data, imageData.width, imageData.height, {
          inversionAttempts: 'dontInvert',
        });

        if (code) qrtpb.processReceivedQRData(code.data);
      };

      // Mode switching function
      const switchMode = async (mode) => {
        // Reset throughput tracking
        window.senderStartTime = null;
        window.receiverStartTime = null;
        window.lastAcknowledged = 0;
        window.lastReceived = 0;

        qrtpb.setMode(mode);

        if (mode === 'send') {
          sendTab.classList.add('active');
          receiveTab.classList.remove('active');
          sendPanel.classList.add('active');
          receivePanel.classList.remove('active');
          stopCamera();

          // Initialize audio backchannel
          try {
            await initAudioBackchannel();
          } catch (e) {
            console.error('Failed to initialize audio backchannel:', e);
          }

          // Initialize with any existing text
          const text = txData.value.trim();
          if (text) qrtpb.setData(text);
        } else {
          sendTab.classList.remove('active');
          receiveTab.classList.add('active');
          sendPanel.classList.remove('active');
          receivePanel.classList.add('active');
          startCamera();

          // Initialize audio backchannel
          try {
            await initAudioBackchannel();
          } catch (e) {
            console.error('Failed to initialize audio backchannel:', e);
          }
        }
      };

      // Event listeners
      sendTab.addEventListener('click', () => switchMode('send'));
      receiveTab.addEventListener('click', () => switchMode('receive'));

      txData.addEventListener('input', () => {
        const text = txData.value.trim();
        if (text) qrtpb.setData(text);
        else qrtpb.reset();
      });

      cameraOverlay.addEventListener('click', () => {
        if (videoStream) stopCamera();
        else startCamera();
      });

      // Show chunk size info
      document.getElementById('chunkInfo').textContent = `Using ${QRTPB.DEFAULT_CHUNK_SIZE} bytes per chunk`;

      // Start in send mode
      switchMode('send');

      // Clean up function
      window.addEventListener('beforeunload', () => {
        audioWave.dispose();
        qrtpb.dispose();
      });
    </script>
  </body>
</html>
