<!doctype html>
<html lang="en-us">
  <head>
    <title>QR with Audio Backchannel</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      * {
        box-sizing: border-box;
      }

      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        font-family: system-ui, sans-serif;
        background-color: #f5f5f5;
        overflow-x: hidden;
        min-height: 100vh;
        position: relative;
      }

      .app-container {
        max-width: 900px;
        margin: 0 auto;
        padding: 24px 16px;
      }

      .title {
        font-size: 24px;
        font-weight: 600;
        text-align: center;
        margin-bottom: 24px;
        color: #000;
      }

      .mode-selector {
        display: flex;
        justify-content: center;
        margin-bottom: 20px;
        gap: 10px;
      }

      .mode-btn {
        padding: 10px 20px;
        background-color: #eee;
        border: 1px solid #000;
        cursor: pointer;
        font-weight: 500;
        transition: background-color 0.2s ease;
      }

      .mode-btn.active {
        background-color: #000;
        color: #fff;
      }

      .media-container {
        display: flex;
        flex-direction: row;
        gap: 20px;
        margin-bottom: 24px;
      }

      .qr-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: center;
        margin: 0;
        aspect-ratio: 1;
        max-width: none;
      }

      #qrcode {
        width: 100%;
        flex-grow: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 1px solid #00000024;
      }

      #qrcode canvas {
        max-width: 100%;
        max-height: 100%;
      }

      #videoContainer {
        flex: 1;
        position: relative;
        overflow: hidden;
        background-color: #000;
        cursor: pointer;
        aspect-ratio: 1;
        margin: 0;
      }

      #video {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .camera-overlay {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: rgba(0, 0, 0, 0.5);
        transition: opacity 0.3s ease;
      }

      .camera-label {
        color: white;
        font-size: 16px;
        font-weight: 500;
        text-align: center;
        padding: 10px;
      }

      .camera-active .camera-overlay {
        opacity: 0;
        visibility: hidden;
      }

      @media (hover: hover) {
        .camera-active:hover .camera-overlay {
          opacity: 1;
          visibility: visible;
          background-color: rgba(0, 0, 0, 0.7);
        }
      }

      .progress-bar-container {
        height: 40px;
        background-color: #f0f0f0;
        margin-top: 10px;
        overflow: hidden;
        position: relative;
        border: 1px solid #000;
        display: flex;
      }

      .progress-segment {
        height: 100%;
        flex: 1;
        position: relative;
      }

      .progress-segment:last-child {
        border-right: none;
      }

      .progress-segment.received {
        background-color: #4caf50;
      }

      .progress-segment.missing {
        background-color: #f44336;
      }

      .progress-segment.current {
        background-color: #ff9800;
      }

      .progress-segment.current.received {
        background-color: #4caf50;
      }

      .progress-text {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #fff;
        font-size: 14px;
        font-weight: 600;
        z-index: 2;
        mix-blend-mode: difference;
        pointer-events: none;
      }

      .progress-section {
        margin-top: 20px;
        display: flex;
        gap: 20px;
      }

      .progress-column {
        flex: 1;
      }

      .progress-title {
        font-size: 14px;
        margin-bottom: 8px;
        color: #000;
        font-weight: 500;
      }

      .received-text {
        margin-top: 10px;
        padding: 12px;
        background-color: #f9f9f9;
        border: 1px solid #000;
        font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
        font-size: 14px;
        line-height: 1.4;
        white-space: pre-wrap;
        word-break: break-all;
        height: 100px;
        overflow-y: auto;
      }

      .input-text {
        margin-top: 10px;
        width: 100%;
        height: 100px;
        border: 1px solid #000;
        padding: 12px;
        font-size: 14px;
        resize: none;
        margin-bottom: 0px;
      }

      .visualizer-container {
        width: 100%;
        height: 50px;
        border: 1px solid #000;
        margin-top: 10px;
        background-color: #000;
        position: relative;
      }

      #audioVisualizer {
        width: 100%;
        height: 100%;
      }

      .qr-success-message {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        width: 100%;
        color: #4caf50;
        text-align: center;
        font-weight: bold;
        padding: 20px;
        background-color: #e8f5e9;
        border-radius: 8px;
      }

      .qr-success-message .icon {
        font-size: 48px;
        margin-bottom: 10px;
      }

      .qr-success-message .text {
        font-size: 16px;
      }

      .highlight-chunk {
        background-color: #ffff00;
        animation: fadeHighlight 2s forwards;
      }

      @keyframes fadeHighlight {
        from {
          background-color: #ffff00;
        }
        to {
          background-color: transparent;
        }
      }

      .checksum-display {
        padding: 4px 8px;
        background-color: #f0f0f0;
        border-left: 3px solid #666;
        border-radius: 3px;
        font-weight: 500;
        font-family: monospace;
        font-size: 12px;
        color: #666;
        margin-top: 8px;
      }

      .checksum-display.match {
        background-color: #e8f5e8;
        border-left-color: #4caf50;
        color: #2e7d32;
      }

      .checksum-display.mismatch {
        background-color: #ffeaea;
        border-left-color: #f44336;
        color: #c62828;
      }

      .speed-label {
        font-size: 11px;
        color: #666;
        margin-top: 5px;
      }

      /* Show/hide elements based on mode */
      .receiver-mode .qr-container,
      .receiver-mode .progress-column.sending-column {
        display: none;
      }

      .receiver-mode .media-container #videoContainer {
        flex: 1;
        max-width: 100%;
        margin: 0 auto;
      }

      .receiver-mode .progress-column.receiving-column {
        max-width: 100%;
      }

      /* Mobile responsiveness */
      @media (max-width: 768px) {
        .title {
          font-size: 20px;
        }

        .media-container {
          flex-direction: column;
          margin-bottom: 0px;
        }

        .qr-container,
        #videoContainer {
          width: 100%;
          max-width: 400px;
          margin: 0 auto;
        }

        .progress-section {
          flex-direction: column;
        }

        .progress-column {
          margin-bottom: 20px;
        }
      }
    </style>
  </head>
  <body>
    <!-- Silent audio for iOS audio context initialization -->
    <audio
      class="iphone-silence"
      src="https://github.com/chee/bento/raw/main/public/aux/iphone-silence.flac"
      loop
      autoplay
      preload="auto"
      style="display: none"
    ></audio>

    <div class="app-container">
      <div class="title">QR Transfer with Audio Backchannel</div>

      <!-- Mode selector -->
      <div class="mode-selector">
        <div id="senderBtn" class="mode-btn active">Sender</div>
        <div id="receiverBtn" class="mode-btn">Receiver</div>
      </div>

      <!-- Main media container -->
      <div class="media-container">
        <div class="qr-container">
          <div id="qrcode"></div>
        </div>

        <!-- Camera view -->
        <div id="videoContainer">
          <video id="video" playsinline></video>
          <div class="camera-overlay">
            <div class="camera-label">Start Camera</div>
          </div>
        </div>
      </div>

      <!-- Audio visualizer -->
      <div class="visualizer-container">
        <canvas id="audioVisualizer"></canvas>
      </div>

      <!-- Progress bars for sending and receiving -->
      <div class="progress-section">
        <div class="progress-column sending-column">
          <div class="progress-title">Sending</div>
          <div class="progress-bar-container" id="sendingProgress">
            <div class="progress-text">0/0</div>
          </div>
          <textarea id="txData" class="input-text">Hello from QRTPB!</textarea>
          <div id="senderChecksum" class="checksum-display" style="display: none"></div>
          <div id="senderSpeed" class="speed-label">Average: 0 b/s</div>
        </div>
        <div class="progress-column receiving-column">
          <div class="progress-title">Receiving</div>
          <div class="progress-bar-container" id="receivingProgress">
            <div class="progress-text">0/0</div>
          </div>
          <div id="receivedText" class="received-text"></div>
          <div id="receiverChecksum" class="checksum-display" style="display: none"></div>
          <div id="receiverSpeed" class="speed-label">Average: 0 b/s</div>
        </div>
      </div>
    </div>

    <!-- QR Code libraries -->
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>

    <script type="module">
      import QrScanner from 'https://cdn.jsdelivr.net/npm/qr-scanner@1.4.2/qr-scanner.min.js';
      import { QRTPB } from '@folkjs/labs/QRTP-B';

      // Core state
      let qrScanner = null;
      let cameraActive = false;
      let qrProtocol = new QRTPB();
      let currentMode = 'sender';
      let currentSendingStream = null;
      let silenceAudio = document.querySelector('.iphone-silence');
      let audioInitialized = false;

      // Transfer statistics
      let transferStats = {
        startTime: null,
        totalBytes: 0,
        chunkSize: 0,
      };

      // DOM elements
      const elements = {
        txData: document.getElementById('txData'),
        qrcode: document.getElementById('qrcode'),
        video: document.getElementById('video'),
        videoContainer: document.getElementById('videoContainer'),
        cameraLabel: document.querySelector('.camera-label'),
        sendingProgress: document.getElementById('sendingProgress'),
        receivingProgress: document.getElementById('receivingProgress'),
        receivedText: document.getElementById('receivedText'),
        senderBtn: document.getElementById('senderBtn'),
        receiverBtn: document.getElementById('receiverBtn'),
        audioVisualizer: document.getElementById('audioVisualizer'),
        senderChecksum: document.getElementById('senderChecksum'),
        receiverChecksum: document.getElementById('receiverChecksum'),
        senderSpeed: document.getElementById('senderSpeed'),
        receiverSpeed: document.getElementById('receiverSpeed'),
      };

      // Initialize app
      document.addEventListener('DOMContentLoaded', init);

      function init() {
        setupProtocolEvents();
        setupUIEvents();
        setupVisualizer();
        setupAudioInitialization();
        setupVisibilityHandling();

        updateQRCode('Initializing...');
        configureSenderWithoutAudio();

        // Update speed labels periodically
        setInterval(updateSpeedLabels, 1000);
      }

      // Audio initialization
      async function initializeAudioContext() {
        if (audioInitialized) return;

        try {
          if (silenceAudio) {
            await silenceAudio.play();
          }
          audioInitialized = true;
        } catch (error) {
          console.warn('Audio initialization failed:', error);
        }
      }

      function setupAudioInitialization() {
        const initializeOnInteraction = async () => {
          await initializeAudioContext();
          document.removeEventListener('click', initializeOnInteraction);
          document.removeEventListener('touchstart', initializeOnInteraction);
          document.removeEventListener('keydown', initializeOnInteraction);
        };

        document.addEventListener('click', initializeOnInteraction);
        document.addEventListener('touchstart', initializeOnInteraction);
        document.addEventListener('keydown', initializeOnInteraction);
      }

      function setupVisibilityHandling() {
        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            if (silenceAudio && !qrProtocol?.isActive) {
              silenceAudio.pause();
              silenceAudio.load();
              if (silenceAudio.parentNode) {
                silenceAudio.parentNode.removeChild(silenceAudio);
              }
            }
          } else {
            if (silenceAudio && !silenceAudio.parentNode) {
              document.body.appendChild(silenceAudio);
              if (audioInitialized) {
                silenceAudio.play().catch((e) => console.warn('Could not restart silent audio:', e));
              }
            }
          }
        });
      }

      // Audio visualizer setup
      function setupVisualizer() {
        const canvas = elements.audioVisualizer;
        const ctx = canvas.getContext('2d');
        const WIDTH = (canvas.width = canvas.parentElement.clientWidth);
        const HEIGHT = (canvas.height = canvas.parentElement.clientHeight);

        let visualizationActive = false;
        let analyser = null;

        window.visualizeAudio = (node, context) => {
          if (!node || !context) {
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            visualizationActive = false;
            return;
          }

          if (!visualizationActive) {
            analyser = context.createAnalyser();
            analyser.fftSize = 256;
            node.connect(analyser);
            visualizationActive = true;
          }

          const bufferLength = analyser.frequencyBinCount;
          const dataArray = new Uint8Array(bufferLength);

          function draw() {
            if (!visualizationActive) return;

            requestAnimationFrame(draw);
            analyser.getByteFrequencyData(dataArray);

            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            const barWidth = (WIDTH / bufferLength) * 2.5;
            let x = 0;

            for (let i = 0; i < bufferLength; i++) {
              const barHeight = (dataArray[i] / 255) * HEIGHT;
              ctx.fillStyle = `rgb(${dataArray[i]}, 100, 200)`;
              ctx.fillRect(x, HEIGHT - barHeight, barWidth, barHeight);
              x += barWidth + 1;
            }
          }

          draw();
        };

        qrProtocol.setAudioVisualizer(window.visualizeAudio);
      }

      // Protocol event handlers
      function setupProtocolEvents() {
        qrProtocol.on('init', (event) => {
          initProgressSegments(elements.sendingProgress, event.total);
          updateProgressText(elements.sendingProgress, 0, event.total);

          if (event.checksum) {
            elements.senderChecksum.style.display = 'block';
            elements.senderChecksum.textContent = `Sender checksum: ${event.checksum}`;
          }

          transferStats = {
            startTime: Date.now(),
            totalBytes: 0,
            chunkSize: event.size,
          };
        });

        qrProtocol.on('chunk', (event) => {
          transferStats.totalBytes += event.payload.length;

          updateReceivedText(event.payload, false);
          updateProgressSegment(elements.receivingProgress, event.index, 'received');

          if (event.receivedIndices && event.receivedIndices.length > 0) {
            if (elements.receivingProgress.querySelectorAll('.progress-segment').length !== event.total) {
              initProgressSegments(elements.receivingProgress, event.total);
            }

            event.receivedIndices.forEach((idx) => {
              updateProgressSegment(elements.receivingProgress, idx, 'received');
            });

            if (currentMode === 'sender') {
              for (let i = 0; i < event.total; i++) {
                if (!event.receivedIndices.includes(i)) {
                  updateProgressSegment(elements.receivingProgress, i, 'missing');
                }
              }
            }
          }
        });

        qrProtocol.on('ack', (event) => {
          event.acknowledged.forEach((index) => {
            updateProgressSegment(elements.sendingProgress, index, 'received');
          });

          if (event.remaining === 0 && event.acknowledged.length > 0) {
            showSuccessMessage();
          }
        });

        qrProtocol.on('complete', (event) => {
          if (event?.message) {
            updateReceivedText(event.message, true);

            if (event.checksum) {
              elements.receiverChecksum.style.display = 'block';
              elements.receiverChecksum.textContent = `Receiver checksum: ${event.checksum}`;

              const senderChecksum = elements.senderChecksum.textContent;
              if (senderChecksum && senderChecksum.includes(event.checksum)) {
                elements.receiverChecksum.classList.add('match');
                elements.receiverChecksum.textContent += ' ✓';
              } else if (senderChecksum) {
                elements.receiverChecksum.classList.add('mismatch');
                elements.receiverChecksum.textContent += ' ✗';
              }
            }

            if (event.receivedIndices && event.totalChunks) {
              if (elements.receivingProgress.querySelectorAll('.progress-segment').length !== event.totalChunks) {
                initProgressSegments(elements.receivingProgress, event.totalChunks);
              }

              event.receivedIndices.forEach((idx) => {
                updateProgressSegment(elements.receivingProgress, idx, 'received');
              });

              updateProgressText(elements.receivingProgress, event.receivedIndices.length, event.totalChunks);

              if (currentMode === 'sender') {
                for (let i = 0; i < event.totalChunks; i++) {
                  if (!event.receivedIndices.includes(i)) {
                    updateProgressSegment(elements.receivingProgress, i, 'missing');
                  }
                }
              }
            }
          }
        });

        qrProtocol.on('allAcknowledged', () => {
          const totalSegments = elements.sendingProgress.querySelectorAll('.progress-segment').length;
          updateProgressText(elements.sendingProgress, totalSegments, totalSegments);
          showSuccessMessage();
        });
      }

      // UI event handlers
      function setupUIEvents() {
        elements.txData.addEventListener('input', async () => {
          if (currentMode === 'sender') {
            const text = elements.txData.value.trim();
            if (text) {
              await startSending(text);
            }
          }
        });

        elements.videoContainer.addEventListener('click', () => {
          cameraActive ? stopCamera() : startCamera();
        });

        elements.senderBtn.addEventListener('click', async () => {
          if (currentMode !== 'sender') {
            currentMode = 'sender';
            elements.senderBtn.classList.add('active');
            elements.receiverBtn.classList.remove('active');
            await configureAsSender();
          }
        });

        elements.receiverBtn.addEventListener('click', async () => {
          if (currentMode !== 'receiver') {
            currentMode = 'receiver';
            elements.receiverBtn.classList.add('active');
            elements.senderBtn.classList.remove('active');
            await configureAsReceiver();
          }
        });
      }

      // Sending functions
      function stopSending() {
        if (currentSendingStream) {
          currentSendingStream.stop = true;
          currentSendingStream = null;
        }
      }

      async function startSending(text) {
        stopSending();
        await initializeAudioContext();

        const stream = qrProtocol.send(text, 500);
        currentSendingStream = { stream, stop: false };

        try {
          for await (const qrItem of stream) {
            if (currentSendingStream?.stop) break;

            updateQRCode(qrItem.data);
            updateCurrentSegment(elements.sendingProgress, qrItem.index, qrItem.total);
          }
        } catch (error) {
          console.error('Error during QR streaming:', error);
        }
      }

      // Mode configuration
      function configureSenderWithoutAudio() {
        if (qrScanner) stopCamera();
        stopSending();

        clearUI();
        document.body.classList.remove('receiver-mode');
        elements.txData.disabled = false;
      }

      async function configureAsSender() {
        if (qrScanner) stopCamera();
        stopSending();

        clearUI();
        document.body.classList.remove('receiver-mode');
        elements.txData.disabled = false;

        const text = elements.txData.value.trim();
        if (text) {
          await startSending(text);
        }
      }

      async function configureAsReceiver() {
        stopSending();

        elements.txData.value = '';
        elements.txData.disabled = true;
        clearUI();

        document.body.classList.add('receiver-mode');

        await initializeAudioContext();
        await qrProtocol.configureReceiver();

        startCamera();
      }

      function clearUI() {
        elements.receivedText.innerHTML = '';
        clearProgressSegments(elements.receivingProgress);
        clearProgressSegments(elements.sendingProgress);
        updateProgressText(elements.receivingProgress, 0, 0);
        updateProgressText(elements.sendingProgress, 0, 0);

        elements.senderChecksum.style.display = 'none';
        elements.senderChecksum.classList.remove('match', 'mismatch');
        elements.receiverChecksum.style.display = 'none';
        elements.receiverChecksum.classList.remove('match', 'mismatch');

        transferStats = { startTime: null, totalBytes: 0, chunkSize: 0 };
      }

      // Camera functions
      async function startCamera() {
        try {
          qrScanner = new QrScanner(elements.video, (result) => qrProtocol.parseCode(result.data), {
            returnDetailedScanResult: true,
            highlightScanRegion: true,
            highlightCodeOutline: true,
            preferredCamera: 'environment',
          });

          await qrScanner.start();

          cameraActive = true;
          elements.videoContainer.classList.add('camera-active');
          elements.cameraLabel.textContent = 'Stop Camera';
        } catch (error) {
          console.error('Camera error:', error);
        }
      }

      function stopCamera() {
        if (qrScanner) {
          qrScanner.stop();
          qrScanner.destroy();
          qrScanner = null;
        }

        cameraActive = false;
        elements.videoContainer.classList.remove('camera-active');
        elements.cameraLabel.textContent = 'Start Camera';
      }

      // UI update functions
      function updateQRCode(qrData) {
        elements.qrcode.innerHTML = '';
        const canvas = document.createElement('canvas');
        elements.qrcode.appendChild(canvas);

        QRCode.toCanvas(canvas, qrData, {
          width: elements.qrcode.clientWidth,
          margin: 4,
        });
      }

      function updateReceivedText(chunkData, isComplete) {
        if (isComplete) {
          elements.receivedText.textContent = chunkData;
        } else {
          const span = document.createElement('span');
          span.className = 'highlight-chunk';
          span.textContent = chunkData;
          elements.receivedText.appendChild(span);
        }
        elements.receivedText.scrollTop = elements.receivedText.scrollHeight;
      }

      function initProgressSegments(container, total) {
        container.innerHTML = '';

        const textElement = document.createElement('div');
        textElement.className = 'progress-text';
        textElement.textContent = `0/${total}`;
        container.appendChild(textElement);

        for (let i = 0; i < total; i++) {
          const segment = document.createElement('div');
          segment.className = 'progress-segment';
          segment.setAttribute('data-index', i);
          segment.title = `Chunk ${i + 1}`;
          container.appendChild(segment);
        }
      }

      function clearProgressSegments(container) {
        const textElement = container.querySelector('.progress-text');
        container.innerHTML = '';
        if (textElement) {
          container.appendChild(textElement);
        }
      }

      function updateProgressSegment(container, index, status) {
        const segment = container.querySelector(`.progress-segment[data-index="${index}"]`);
        if (!segment && container.querySelectorAll('.progress-segment').length === 0) {
          initProgressSegments(container, Math.max(25, index + 1));
          return updateProgressSegment(container, index, status);
        }

        if (segment) {
          segment.title = `Chunk ${parseInt(index) + 1}: ${status}`;

          if (status === 'received') {
            segment.classList.add('received');
            segment.classList.remove('missing');
          } else if (status === 'missing') {
            segment.classList.add('missing');
            segment.classList.remove('received');
          }

          updateProgressCounter(container);
        }
      }

      function updateProgressCounter(container) {
        const received = container.querySelectorAll('.progress-segment.received').length;
        const total = container.querySelectorAll('.progress-segment').length;
        updateProgressText(container, received, total);
      }

      function updateProgressText(container, received, total) {
        const textElement = container.querySelector('.progress-text');
        if (textElement) {
          textElement.textContent = `${received}/${total}`;
        }
      }

      function updateCurrentSegment(container, currentIndex, totalSegments) {
        if (container.querySelectorAll('.progress-segment').length === 0) {
          initProgressSegments(container, totalSegments);
        }

        container.querySelectorAll('.current').forEach((el) => el.classList.remove('current'));

        const segment = container.querySelector(`.progress-segment[data-index="${currentIndex}"]`);
        if (segment) {
          segment.classList.add('current');
        }
      }

      function showSuccessMessage() {
        elements.qrcode.innerHTML = '';

        const successDiv = document.createElement('div');
        successDiv.className = 'qr-success-message';

        const icon = document.createElement('div');
        icon.className = 'icon';
        icon.innerHTML = '✓';
        successDiv.appendChild(icon);

        const text = document.createElement('div');
        text.className = 'text';
        text.textContent = 'Transfer Complete!';
        successDiv.appendChild(text);

        elements.qrcode.appendChild(successDiv);
      }

      // Speed calculation
      function formatBitrate(bitsPerSecond) {
        if (bitsPerSecond < 1000) return `${Math.round(bitsPerSecond)} b/s`;
        if (bitsPerSecond < 1000000) return `${(bitsPerSecond / 1000).toFixed(1)} Kb/s`;
        return `${(bitsPerSecond / 1000000).toFixed(1)} Mb/s`;
      }

      function updateSpeedLabels() {
        if (transferStats.startTime) {
          const totalTime = (Date.now() - transferStats.startTime) / 1000;
          if (totalTime > 0) {
            const avgBitrate = (transferStats.totalBytes * 8) / totalTime;

            if (currentMode === 'receiver') {
              elements.receiverSpeed.textContent = `Average: ${formatBitrate(avgBitrate)}`;
            } else {
              const acknowledgedSegments = elements.sendingProgress.querySelectorAll('.progress-segment.received');
              const bytesTransferred = acknowledgedSegments.length * transferStats.chunkSize;
              const senderBitrate = (bytesTransferred * 8) / totalTime;
              elements.senderSpeed.textContent = `Average: ${formatBitrate(senderBitrate)}`;
            }
          }
        }
      }
    </script>
  </body>
</html>
