<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Infinite ZUI with RelativeScaleTree</title>
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        overflow: hidden;
        background: #f9f9f9;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      }

      #info-container {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: white;
        padding: 8px 10px;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        z-index: 2000;
        max-width: 300px;
        font-size: 12px;
        line-height: 1.4;

        & > div:first-child {
          font-weight: bold;
        }
      }

      #zui-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      .zui-node {
        position: absolute;
        box-sizing: border-box;
        border: 1px solid rgba(0, 0, 0, 0.2);
        overflow: hidden;
        transform-origin: 0 0;
        transition: border-color 0.2s;
      }

      .node-label {
        position: absolute;
        left: 5px;
        top: 5px;
        font-size: 10px;
        color: rgba(0, 0, 0, 0.7);
        pointer-events: none;
      }

      .debug-info {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background-color: white;
        padding: 8px 10px;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        z-index: 2000;
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <div id="info-container">
      <div>Infinite ZUI with RelativeScaleTree</div>
      <div>A zoomable UI with infinite tree-like structure using the RelativeScaleTree implementation.</div>
      <div>Scroll to zoom, drag to pan.</div>
    </div>

    <div id="zui-container"></div>
    <div class="debug-info"></div>

    <script type="module">
      // Store any errors for debugging
      window._zuiErrors = [];

      // Try importing the RelativeScaleTree implementation
      let RelativeScaleTree;
      let ScaleNode;

      try {
        // Dynamic import to catch errors
        const module = await import('@labs/RelativeScaleTree.ts');
        RelativeScaleTree = module.RelativeScaleTree;
        ScaleNode = module.ScaleNode;
        console.log('Successfully imported RelativeScaleTree');
      } catch (e) {
        console.error('Error importing RelativeScaleTree:', e);
        window._zuiErrors.push(`Import error: ${e.message}`);
        // We'll use the fallback implementation instead
      }

      // Fallback implementation in case of import errors
      class SimpleScaleNode {
        constructor(id, parentId, x, y, width, height, color) {
          this.id = id;
          this.parentId = parentId;
          this.bounds = { x, y, width, height };
          this.data = { color };
        }
      }

      class SimpleScaleTree {
        constructor(rootNode) {
          this.nodes = new Map();
          this.nodes.set(rootNode.id, rootNode);
          this.currentNodeId = rootNode.id;
          this.scale = 1;
          this.offset = { x: 0, y: 0 };
          console.log('Created SimpleScaleTree fallback');
        }

        addNode(node) {
          this.nodes.set(node.id, node);
        }

        getNode(nodeId) {
          return this.nodes.get(nodeId);
        }

        getViewState() {
          return {
            currentNodeId: this.currentNodeId,
            scale: this.scale,
            offset: { ...this.offset },
          };
        }

        zoom(factor, focalPointX, focalPointY) {
          this.scale *= factor;
          console.log('SimpleScaleTree zoom', this.scale);
        }

        pan(deltaX, deltaY) {
          this.offset.x += deltaX / this.scale;
          this.offset.y += deltaY / this.scale;
        }

        getCoordinateTransform(nodeId) {
          const node = this.nodes.get(nodeId);
          if (!node) return { x: 0, y: 0, width: 0, height: 0, visible: false };

          // Simple transform for fallback implementation
          if (nodeId === this.currentNodeId) {
            // Current node
            return {
              x: this.offset.x * this.scale,
              y: this.offset.y * this.scale,
              width: node.bounds.width * this.scale,
              height: node.bounds.height * this.scale,
              visible: true,
            };
          } else if (node.parentId === this.currentNodeId) {
            // Direct child of current node
            const parent = this.nodes.get(this.currentNodeId);
            return {
              x: (node.bounds.x + this.offset.x) * this.scale,
              y: (node.bounds.y + this.offset.y) * this.scale,
              width: node.bounds.width * this.scale,
              height: node.bounds.height * this.scale,
              visible: true,
            };
          } else if (node.parentId) {
            // Other nodes with parents
            const parent = this.nodes.get(node.parentId);
            if (parent) {
              const parentTransform = this.getCoordinateTransform(parent.id);
              if (parentTransform.visible) {
                return {
                  x: parentTransform.x + node.bounds.x * this.scale,
                  y: parentTransform.y + node.bounds.y * this.scale,
                  width: node.bounds.width * this.scale,
                  height: node.bounds.height * this.scale,
                  visible: true,
                };
              }
            }
          }

          // Root node or no parent
          const rootTransform = {
            x: node.bounds.x * this.scale,
            y: node.bounds.y * this.scale,
            width: node.bounds.width * this.scale,
            height: node.bounds.height * this.scale,
            visible: true,
          };

          return rootTransform;
        }
      }

      class InfiniteZUI {
        constructor(containerId) {
          // DOM elements
          this.container = document.getElementById(containerId);
          this.debugInfo = document.querySelector('.debug-info');

          // Constants
          this.ZOOM_SENSITIVITY = 0.001;

          // Interaction state
          this.isDragging = false;
          this.lastMouseX = 0;
          this.lastMouseY = 0;

          // Node visualization mappings
          this.nodeElements = new Map();
          this.nodeColors = new Map();

          console.log('Initializing InfiniteZUI');
          // Create tree data structure
          this.initializeTree();
          this.setupEventListeners();
          this.updateDebugInfo();
          this.render();

          // Update debug info with any initialization errors
          if (window._zuiErrors && window._zuiErrors.length > 0) {
            this.debugInfo.innerHTML += `<br>Errors: ${window._zuiErrors.join('<br>')}`;
          }
        }

        initializeTree() {
          try {
            // Create root node
            const rootNode = {
              id: 'root',
              bounds: { x: 0, y: 0, width: 800, height: 600 },
              data: { color: '#f0f0f0' },
            };

            console.log('Creating RelativeScaleTree with root', rootNode);
            // Initialize the RelativeScaleTree with root node
            this.tree = new RelativeScaleTree(rootNode);
            console.log('RelativeScaleTree created successfully');
          } catch (err) {
            console.error('Error creating RelativeScaleTree:', err);
            console.log('Falling back to SimpleScaleTree');

            // Create fallback implementation
            const rootNode = new SimpleScaleNode('root', null, 0, 0, 800, 600, '#f0f0f0');
            this.tree = new SimpleScaleTree(rootNode);
          }

          // Set colors
          this.nodeColors.set('root', '#f0f0f0');

          try {
            // Add children
            this.tree.addNode({
              id: 'child1',
              parentId: 'root',
              bounds: { x: 50, y: 50, width: 300, height: 200 },
              data: { color: '#ffcccc' },
            });
            this.nodeColors.set('child1', '#ffcccc');

            this.tree.addNode({
              id: 'child2',
              parentId: 'root',
              bounds: { x: 400, y: 150, width: 250, height: 250 },
              data: { color: '#ccffcc' },
            });
            this.nodeColors.set('child2', '#ccffcc');

            this.tree.addNode({
              id: 'child3',
              parentId: 'root',
              bounds: { x: 200, y: 300, width: 200, height: 300 },
              data: { color: '#ccccff' },
            });
            this.nodeColors.set('child3', '#ccccff');

            // Add nested children
            this.tree.addNode({
              id: 'subchild1',
              parentId: 'child1',
              bounds: { x: 50, y: 30, width: 100, height: 80 },
              data: { color: '#ffaaaa' },
            });
            this.nodeColors.set('subchild1', '#ffaaaa');

            this.tree.addNode({
              id: 'subchild2',
              parentId: 'child2',
              bounds: { x: 30, y: 50, width: 80, height: 80 },
              data: { color: '#aaffaa' },
            });
            this.nodeColors.set('subchild2', '#aaffaa');

            // Create deeper nesting
            this.tree.addNode({
              id: 'subsubchild',
              parentId: 'subchild1',
              bounds: { x: 20, y: 20, width: 40, height: 30 },
              data: { color: '#ff8888' },
            });
            this.nodeColors.set('subsubchild', '#ff8888');

            console.log('Tree initialized with nodes', this.tree);
          } catch (err) {
            console.error('Error adding nodes:', err);
          }
        }

        setupEventListeners() {
          // Wheel event for zooming
          this.container.addEventListener(
            'wheel',
            (e) => {
              e.preventDefault();

              // Get mouse position relative to container
              const rect = this.container.getBoundingClientRect();
              const mouseX = e.clientX - rect.left;
              const mouseY = e.clientY - rect.top;

              // Calculate zoom factor based on delta
              const zoomFactor = 1 - e.deltaY * this.ZOOM_SENSITIVITY;

              // Apply zoom centered at mouse position
              this.tree.zoom(zoomFactor, mouseX, mouseY);
              this.render();
              this.updateDebugInfo();
            },
            { passive: false },
          );

          // Mouse events for panning
          this.container.addEventListener('mousedown', (e) => {
            this.isDragging = true;
            this.lastMouseX = e.clientX;
            this.lastMouseY = e.clientY;
            this.container.style.cursor = 'grabbing';
          });

          document.addEventListener('mousemove', (e) => {
            if (!this.isDragging) return;

            const dx = e.clientX - this.lastMouseX;
            const dy = e.clientY - this.lastMouseY;

            this.tree.pan(dx, dy);

            this.lastMouseX = e.clientX;
            this.lastMouseY = e.clientY;

            this.render();
            this.updateDebugInfo();
          });

          document.addEventListener('mouseup', () => {
            this.isDragging = false;
            this.container.style.cursor = 'grab';
          });
        }

        render() {
          // Clear container
          this.container.innerHTML = '';
          this.nodeElements.clear();

          // Get all node IDs by iterating through tree
          const viewState = this.tree.getViewState();
          console.log('Rendering with view state:', viewState);

          // Start with the root and render all nodes
          this.renderNode('root');
          this.renderNode('child1');
          this.renderNode('child2');
          this.renderNode('child3');
          this.renderNode('subchild1');
          this.renderNode('subchild2');
          this.renderNode('subsubchild');
        }

        renderNode(nodeId) {
          const node = this.tree.getNode(nodeId);
          if (!node) {
            console.warn(`Node ${nodeId} not found`);
            return;
          }
          console.log(`Rendering node ${nodeId}:`, node);

          // Get node's transform relative to current view
          const transform = this.tree.getCoordinateTransform(nodeId);
          console.log(`Transform for ${nodeId}:`, transform);

          if (!transform.visible) {
            console.log(`Node ${nodeId} is not visible`);
            return;
          }

          // Create element
          const element = document.createElement('div');
          element.className = 'zui-node';
          element.id = `node-${nodeId}`;

          // Apply node properties
          element.style.backgroundColor = this.nodeColors.get(nodeId) || '#dddddd';
          element.style.width = `${transform.width}px`;
          element.style.height = `${transform.height}px`;
          element.style.transform = `translate(${transform.x}px, ${transform.y}px)`;

          // Add logging for element styling
          console.log(`Styled element for ${nodeId}:`, {
            width: `${transform.width}px`,
            height: `${transform.height}px`,
            transform: `translate(${transform.x}px, ${transform.y}px)`,
            backgroundColor: this.nodeColors.get(nodeId) || '#dddddd',
          });

          // Add a label showing node ID
          const label = document.createElement('div');
          label.className = 'node-label';
          label.textContent = nodeId;
          element.appendChild(label);

          // Add to DOM
          this.container.appendChild(element);
          this.nodeElements.set(nodeId, element);
          console.log(`Added element for ${nodeId} to DOM`);
        }

        updateDebugInfo() {
          const viewState = this.tree.getViewState();
          this.debugInfo.textContent = `Scale: ${viewState.scale.toFixed(6)} | Base Node: ${viewState.currentNodeId} | Offset: (${viewState.offset.x.toFixed(2)}, ${viewState.offset.y.toFixed(2)})`;
        }
      }

      // Initialize the ZUI when the page loads
      window.addEventListener('DOMContentLoaded', () => {
        // Use a timeout to ensure the module is loaded
        setTimeout(() => {
          try {
            const zui = new InfiniteZUI('zui-container');
          } catch (e) {
            console.error('Error initializing ZUI:', e);
            document.querySelector('.debug-info').textContent = `Error: ${e.message}`;
          }
        }, 100);
      });
    </script>
  </body>
</html>
