<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Infinite ZUI</title>
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        overflow: hidden;
        background: #f9f9f9;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      }

      #info-container {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: white;
        padding: 8px 10px;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        z-index: 2000;
        max-width: 300px;
        font-size: 12px;
        line-height: 1.4;

        & > div:first-child {
          font-weight: bold;
        }
      }

      #zui-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      .zui-node {
        position: absolute;
        box-sizing: border-box;
        border: 1px solid rgba(0, 0, 0, 0.2);
        overflow: hidden;
        transform-origin: 0 0;
        transition: border-color 0.2s;
      }

      .node-label {
        position: absolute;
        left: 5px;
        top: 5px;
        font-size: 10px;
        color: rgba(0, 0, 0, 0.7);
        pointer-events: none;
      }

      .debug-info {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background-color: white;
        padding: 8px 10px;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        z-index: 2000;
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <div id="info-container">
      <div>Infinite ZUI</div>
      <div>A zoomable UI with infinite tree-like structure.</div>
      <div>Scroll to zoom, drag to pan.</div>
    </div>

    <div id="zui-container"></div>
    <div class="debug-info"></div>

    <script>
      class ZUINode {
        constructor(id, width, height, color, children = []) {
          this.id = id;
          this.width = width;
          this.height = height;
          this.color = color;
          this.children = children;
          this.x = 0;
          this.y = 0;
          this.element = null;
        }

        addChild(child) {
          this.children.push(child);
          return child;
        }
      }

      class InfiniteZUI {
        constructor(containerId) {
          // DOM elements
          this.container = document.getElementById(containerId);
          this.debugInfo = document.querySelector('.debug-info');

          // View state
          this.scale = 1;
          this.offsetX = 0;
          this.offsetY = 0;
          this.baseNodeId = 'root'; // Current base node for coordinate rebasing

          // Node management
          this.nodes = new Map();
          this.rootNode = null;

          // Interaction state
          this.isDragging = false;
          this.lastMouseX = 0;
          this.lastMouseY = 0;

          // Constants
          this.ZOOM_SENSITIVITY = 0.001;
          this.MAX_SCALE = 1000000;
          this.MIN_SCALE = 0.00001;
          this.REBASE_THRESHOLD_MAX = 100;
          this.REBASE_THRESHOLD_MIN = 0.01;

          this.setupEventListeners();
        }

        setupEventListeners() {
          // Wheel event for zooming
          this.container.addEventListener(
            'wheel',
            (e) => {
              e.preventDefault();

              // Get mouse position relative to container
              const rect = this.container.getBoundingClientRect();
              const mouseX = e.clientX - rect.left;
              const mouseY = e.clientY - rect.top;

              // Calculate zoom factor based on delta
              const zoomFactor = 1 - e.deltaY * this.ZOOM_SENSITIVITY;

              // Apply zoom centered at mouse position
              this.zoom(zoomFactor, mouseX, mouseY);
            },
            { passive: false },
          );

          // Mouse events for panning
          this.container.addEventListener('mousedown', (e) => {
            this.isDragging = true;
            this.lastMouseX = e.clientX;
            this.lastMouseY = e.clientY;
            this.container.style.cursor = 'grabbing';
          });

          document.addEventListener('mousemove', (e) => {
            if (!this.isDragging) return;

            const dx = e.clientX - this.lastMouseX;
            const dy = e.clientY - this.lastMouseY;

            this.offsetX += dx / this.scale;
            this.offsetY += dy / this.scale;

            this.lastMouseX = e.clientX;
            this.lastMouseY = e.clientY;

            this.render();
          });

          document.addEventListener('mouseup', () => {
            this.isDragging = false;
            this.container.style.cursor = 'grab';
          });
        }

        zoom(factor, centerX, centerY) {
          // Calculate world coordinates of zoom center
          const worldX = centerX / this.scale - this.offsetX;
          const worldY = centerY / this.scale - this.offsetY;

          // Apply zoom factor
          const newScale = Math.max(this.MIN_SCALE, Math.min(this.MAX_SCALE, this.scale * factor));

          // Adjust offset to keep the point under mouse fixed
          this.offsetX = -(worldX - centerX / newScale);
          this.offsetY = -(worldY - centerY / newScale);

          this.scale = newScale;

          // Check if we need to rebase coordinates
          this.checkAndRebaseCoordinates();

          this.render();
          this.updateDebugInfo();
        }

        checkAndRebaseCoordinates() {
          const baseNode = this.nodes.get(this.baseNodeId);
          if (!baseNode) return;

          // Zooming in: Check if any child node fills the screen
          for (const child of baseNode.children) {
            if (this.nodeCoversScreen(child.id)) {
              this.rebaseToChild(child.id);
              return;
            }
          }

          // Zooming out: Check if current base node no longer covers most of the screen
          // and we're not already at the root
          if (this.baseNodeId !== 'root' && !this.nodeCoversScreenSignificantly(this.baseNodeId)) {
            console.log(`Base node ${this.baseNodeId} no longer covers screen, rebasing to parent`);
            this.rebaseToParent();
            return;
          }
        }

        rebaseToChild(childId) {
          // Find child node to rebase to
          const baseNode = this.nodes.get(this.baseNodeId);
          if (!baseNode) return;

          // If specific child ID is provided, use it, otherwise use first child
          const targetChildId = childId || (baseNode.children.length > 0 ? baseNode.children[0].id : null);
          if (!targetChildId) return;

          const childNode = this.nodes.get(targetChildId);
          if (!childNode) return;

          // Track the node's screen position and size before rebasing
          const nodeScreenPos = this.getNodeScreenPosition(targetChildId);

          // Temporarily store the old base node ID
          const oldBaseId = this.baseNodeId;

          // Update base node ID
          this.baseNodeId = targetChildId;

          // Calculate new scale that preserves the visual size
          this.scale = nodeScreenPos.width / childNode.width;

          // Set new offsets to maintain the node position on screen
          this.offsetX = nodeScreenPos.x / this.scale;
          this.offsetY = nodeScreenPos.y / this.scale;

          console.log(`Rebased from ${oldBaseId} to child: ${targetChildId}`);
          this.render();
          this.updateDebugInfo();
        }

        rebaseToParent() {
          // Find the parent of current base node
          const baseNode = this.nodes.get(this.baseNodeId);
          if (!baseNode || this.baseNodeId === 'root') return;

          // Find parent node
          let parentNode = null;
          for (const node of this.nodes.values()) {
            if (node.children.some((child) => child.id === this.baseNodeId)) {
              parentNode = node;
              break;
            }
          }

          if (!parentNode) return;

          // Get current base node's position on screen
          const baseScreenPos = this.getNodeScreenPosition(this.baseNodeId);

          // Store old base ID
          const oldBaseId = this.baseNodeId;

          // Update base node to parent
          this.baseNodeId = parentNode.id;

          // Calculate new scale to maintain the same visual size of node
          this.scale = baseScreenPos.width / baseNode.width;

          // Calculate new offsets that maintain the position of the child
          this.offsetX = baseScreenPos.x / this.scale - baseNode.x;
          this.offsetY = baseScreenPos.y / this.scale - baseNode.y;

          console.log(`Rebased from ${oldBaseId} to parent: ${parentNode.id}`);
          this.render();
          this.updateDebugInfo();
        }

        createTree() {
          // Create root node
          const root = new ZUINode('root', 800, 600, '#f0f0f0');
          this.nodes.set(root.id, root);
          this.rootNode = root;

          // Create some children
          const child1 = root.addChild(new ZUINode('child1', 300, 200, '#ffcccc'));
          child1.x = 50;
          child1.y = 50;
          this.nodes.set(child1.id, child1);

          const child2 = root.addChild(new ZUINode('child2', 250, 250, '#ccffcc'));
          child2.x = 400;
          child2.y = 150;
          this.nodes.set(child2.id, child2);

          const child3 = root.addChild(new ZUINode('child3', 200, 300, '#ccccff'));
          child3.x = 200;
          child3.y = 300;
          this.nodes.set(child3.id, child3);

          // Add nested children
          const subchild1 = child1.addChild(new ZUINode('subchild1', 100, 80, '#ffaaaa'));
          subchild1.x = 50;
          subchild1.y = 30;
          this.nodes.set(subchild1.id, subchild1);

          const subchild2 = child2.addChild(new ZUINode('subchild2', 80, 80, '#aaffaa'));
          subchild2.x = 30;
          subchild2.y = 50;
          this.nodes.set(subchild2.id, subchild2);

          // Create deeper nesting
          const subsubchild = subchild1.addChild(new ZUINode('subsubchild', 40, 30, '#ff8888'));
          subsubchild.x = 20;
          subsubchild.y = 20;
          this.nodes.set(subsubchild.id, subsubchild);
        }

        render() {
          // Clear container
          this.container.innerHTML = '';

          // Get base node for coordinate transformation
          const baseNode = this.nodes.get(this.baseNodeId);
          if (!baseNode) return;

          // Render the tree starting from the root
          this.renderNode(this.rootNode, {
            x: this.offsetX,
            y: this.offsetY,
            scale: this.scale,
            parent: null,
            baseNodeId: this.baseNodeId,
          });
        }

        renderNode(node, context) {
          // Create or update DOM element for this node
          const element = document.createElement('div');
          element.className = 'zui-node';
          element.id = `node-${node.id}`;

          // Apply node properties
          element.style.backgroundColor = node.color;

          // Scale border inversely to keep consistent visual width
          const borderWidth = 1 / context.scale;
          element.style.borderWidth = `${borderWidth}px`;

          // Add a label showing node ID for debugging
          const label = document.createElement('div');
          label.className = 'node-label';
          label.textContent = node.id;

          // Use fixed font size instead of scaling inversely
          // This will maintain consistent label size relative to viewport
          label.style.fontSize = '10px';
          label.style.padding = '5px';
          element.appendChild(label);

          // Calculate position relative to base node
          let relX, relY;

          if (node.id === this.baseNodeId) {
            // Base node is at the view offset
            relX = 0;
            relY = 0;
          } else {
            // Get relative position to base node
            const relPos = this.getRelativePosition(node.id, this.baseNodeId);
            relX = relPos.x;
            relY = relPos.y;
          }

          // Apply actual dimensions based on scale instead of using CSS transform scale
          const scaledWidth = node.width * context.scale;
          const scaledHeight = node.height * context.scale;
          element.style.width = `${scaledWidth}px`;
          element.style.height = `${scaledHeight}px`;

          // Position the element using translated coordinates without scaling
          const posX = (relX + context.x) * context.scale;
          const posY = (relY + context.y) * context.scale;
          element.style.transform = `translate(${posX}px, ${posY}px)`;

          // Add to DOM
          this.container.appendChild(element);
          node.element = element;

          // Render children with same context
          for (const child of node.children) {
            this.renderNode(child, context);
          }
        }

        updateDebugInfo() {
          this.debugInfo.textContent = `Scale: ${this.scale.toFixed(6)} | Base Node: ${this.baseNodeId} | Offset: (${this.offsetX.toFixed(2)}, ${this.offsetY.toFixed(2)})`;
        }

        // Calculate the position of a node on screen
        getNodeScreenPosition(nodeId) {
          const node = this.nodes.get(nodeId);
          if (!node) return { x: 0, y: 0, width: 0, height: 0 };

          // Special case for base node
          if (nodeId === this.baseNodeId) {
            return {
              x: this.offsetX * this.scale,
              y: this.offsetY * this.scale,
              width: node.width * this.scale,
              height: node.height * this.scale,
            };
          }

          // Get relative position to base node
          const relPos = this.getRelativePosition(nodeId, this.baseNodeId);

          // Calculate screen position
          return {
            x: (relPos.x + this.offsetX) * this.scale,
            y: (relPos.y + this.offsetY) * this.scale,
            width: node.width * this.scale,
            height: node.height * this.scale,
          };
        }

        // Get the relative position between two nodes
        getRelativePosition(nodeId, referenceNodeId) {
          if (nodeId === referenceNodeId) return { x: 0, y: 0 };

          // Get absolute positions
          const nodePos = this.getAbsolutePosition(nodeId);
          const refPos = this.getAbsolutePosition(referenceNodeId);

          // Calculate relative position
          return {
            x: nodePos.x - refPos.x,
            y: nodePos.y - refPos.y,
          };
        }

        // Get absolute position of a node (relative to coordinate space origin)
        getAbsolutePosition(nodeId) {
          const node = this.nodes.get(nodeId);
          if (!node) return { x: 0, y: 0 };

          if (nodeId === 'root') return { x: 0, y: 0 };

          // Find the path from root to this node
          const path = this.getPathToNode(nodeId);
          if (!path) return { x: 0, y: 0 };

          // Calculate position by adding all offsets along the path
          let x = 0;
          let y = 0;

          // Skip root (index 0) since it's at origin
          for (let i = 1; i < path.length; i++) {
            const pathNode = this.nodes.get(path[i]);
            if (pathNode) {
              x += pathNode.x;
              y += pathNode.y;
            }
          }

          return { x, y };
        }

        // Check if a node covers a significant portion of the screen (used for zoom-in)
        nodeCoversScreen(nodeId) {
          const node = this.nodes.get(nodeId);
          if (!node) return false;

          // Get screen dimensions
          const screenWidth = this.container.clientWidth;
          const screenHeight = this.container.clientHeight;

          // Get node's position on screen
          const nodeScreen = this.getNodeScreenPosition(nodeId);

          // Calculate coverage percentage
          const visibleWidth = Math.min(nodeScreen.x + nodeScreen.width, screenWidth) - Math.max(nodeScreen.x, 0);
          const visibleHeight = Math.min(nodeScreen.y + nodeScreen.height, screenHeight) - Math.max(nodeScreen.y, 0);

          // Node is visible
          if (visibleWidth <= 0 || visibleHeight <= 0) return false;

          const visibleArea = visibleWidth * visibleHeight;
          const screenArea = screenWidth * screenHeight;
          const coverage = visibleArea / screenArea;

          // Debug coverage for zoom in
          console.log(`Zoom-in check: Node ${nodeId} covers ${(coverage * 100).toFixed(2)}% of screen`);

          // Node must cover at least 99% of the screen for zooming in
          // A very strict threshold that requires the node to fully cover the screen
          return coverage > 0.99;
        }

        // Check if a node still covers a significant portion of the screen (used for zoom-out)
        nodeCoversScreenSignificantly(nodeId) {
          const node = this.nodes.get(nodeId);
          if (!node) return false;

          // Get screen dimensions
          const screenWidth = this.container.clientWidth;
          const screenHeight = this.container.clientHeight;

          // Get node's position on screen
          const nodeScreen = this.getNodeScreenPosition(nodeId);

          // Calculate coverage percentage
          const visibleWidth = Math.min(nodeScreen.x + nodeScreen.width, screenWidth) - Math.max(nodeScreen.x, 0);
          const visibleHeight = Math.min(nodeScreen.y + nodeScreen.height, screenHeight) - Math.max(nodeScreen.y, 0);

          // Node is visible
          if (visibleWidth <= 0 || visibleHeight <= 0) return false;

          const visibleArea = visibleWidth * visibleHeight;
          const screenArea = screenWidth * screenHeight;
          const coverage = visibleArea / screenArea;

          // Debug coverage for zoom out
          console.log(`Zoom-out check: Node ${nodeId} covers ${(coverage * 100).toFixed(2)}% of screen`);

          // For zoom out, node must still cover at least 98% of screen
          // Slightly lower than zoom-in threshold to prevent jitter
          return coverage > 0.98;
        }

        // Get path from root to node
        getPathToNode(nodeId) {
          if (nodeId === 'root') return ['root'];

          const findPath = (currentNodeId, path = []) => {
            const currentNode = this.nodes.get(currentNodeId);
            if (!currentNode) return null;

            const newPath = [...path, currentNodeId];

            // Found the target node
            if (currentNodeId === nodeId) return newPath;

            // Check children
            for (const child of currentNode.children) {
              const result = findPath(child.id, newPath);
              if (result) return result;
            }

            return null;
          };

          return findPath('root');
        }

        // Get the world position of a node (coordinates relative to root)
        getNodeWorldPosition(nodeId) {
          const path = this.getPathToNode(nodeId);
          if (!path) return { x: 0, y: 0 };

          let worldX = 0;
          let worldY = 0;

          // Skip the root node (first in path) when accumulating offsets
          for (let i = 0; i < path.length; i++) {
            const node = this.nodes.get(path[i]);
            if (node) {
              worldX += node.x;
              worldY += node.y;
            }
          }

          return { x: worldX, y: worldY };
        }

        init() {
          this.createTree();
          this.container.style.cursor = 'grab';
          this.render();
          this.updateDebugInfo();
        }
      }

      // Initialize the ZUI when the page loads
      window.addEventListener('DOMContentLoaded', () => {
        const zui = new InfiniteZUI('zui-container');
        zui.init();
      });
    </script>
  </body>
</html>
