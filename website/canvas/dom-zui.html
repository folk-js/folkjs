<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DOM-based ZUI</title>
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        overflow: hidden;
        background: #f9f9f9;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      }

      #info-container {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: white;
        padding: 8px 10px;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        z-index: 2000;
        max-width: 300px;
        font-size: 12px;
        line-height: 1.4;

        & > div:first-child {
          font-weight: bold;
        }
      }

      #zui-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      .node {
        position: absolute;
        transform-origin: center;
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        color: white;
        border: 2px solid black;
        box-sizing: border-box;
        user-select: none;
        font-size: 14px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        overflow: hidden;
      }

      .node-content {
        padding: 10px;
        width: 100%;
        height: 100%;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        text-align: left;
        position: relative;
        justify-content: flex-start;
      }

      .node h3 {
        margin: 0 0 5px 0;
        font-size: 1.2em;
      }

      .node p {
        margin: 0;
        font-size: 0.9em;
      }

      /* Style for the node links */
      .zui-link {
        display: block;
        position: relative;
        width: 100px;
        height: 60px; /* Maintain the same 5:3 aspect ratio */
        margin: 20px 0;
        background-color: rgba(255, 255, 255, 0.3);
        border: 2px dashed rgba(0, 0, 0, 0.5);
        border-radius: 8px;
        text-decoration: none;
        color: black;
        font-weight: bold;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 12px;
        cursor: pointer;
        z-index: 10;
        /* Keep the same aspect ratio as nodes */
        aspect-ratio: 5/3;
      }

      .zui-link:hover {
        background-color: rgba(255, 255, 255, 0.5);
        transform: scale(1.05);
      }

      #debug-panel {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background-color: rgba(255, 255, 255, 0.8);
        padding: 8px;
        border-radius: 4px;
        font-family: monospace;
        font-size: 12px;
        z-index: 2000;
      }
    </style>
  </head>
  <body>
    <div id="info-container">
      <div>DOM-based Infinite ZUI</div>
      <div>Zoom in/out forever using a <em>floating origin graph</em> with DOM elements.</div>
      <br />
      <div>Hold <kbd>shift</kbd> to zoom in, <kbd>alt+shift</kbd> to zoom out.</div>
      <div id="reference-node-info">coordinate frame: nodeA</div>
    </div>

    <div id="debug-panel">
      <div id="debug-info"></div>
      <div id="visible-nodes"></div>
    </div>

    <div id="zui-container"></div>

    <script type="module">
      import { FloatingOriginGraph } from '@labs/FloatingOriginGraph.ts';

      // Define constants for node dimensions
      const NODE_WIDTH = 500;
      const NODE_HEIGHT = 300;

      // Define nodes as an array for our simple 3-node cycle
      const nodesArray = [
        {
          id: 'nodeA',
          data: {
            color: 'red',
            content: `
              <h3>Node A</h3>
              <p>This is the main node with regular text content. It contains a link to Node B below.</p>
              <a href="#" class="zui-link" data-target="nodeB">Link to Node B</a>
            `,
          },
        },
        {
          id: 'nodeB',
          data: {
            color: 'blue',
            content: `
              <h3>Node B</h3>
              <p>This node is embedded inside Node A. You can continue exploring by following the link to Node C.</p>
              <a href="#" class="zui-link" data-target="nodeC">Link to Node C</a>
            `,
          },
        },
        {
          id: 'nodeC',
          data: {
            color: 'green',
            content: `
              <h3>Node C</h3>
              <p>Now we're deep in the hierarchy. This node is contained within Node B.</p>
              <p>The link below will take you back to Node A, creating an infinite loop!</p>
              <a href="#" class="zui-link" data-target="nodeA">Back to Node A</a>
            `,
          },
        },
      ];

      // Function to create a node element
      function createNodeElement(nodeId, instanceId) {
        const node = graph.nodes[nodeId];
        if (!node) return null;

        const nodeElement = document.createElement('div');
        nodeElement.classList.add('node');
        nodeElement.id = `node-${nodeId}-${instanceId}`;
        nodeElement.dataset.nodeId = nodeId;
        nodeElement.dataset.instanceId = instanceId;
        nodeElement.style.width = `${NODE_WIDTH}px`;
        nodeElement.style.height = `${NODE_HEIGHT}px`;
        nodeElement.style.backgroundColor = node.data.color;

        // Create a content container
        const contentElement = document.createElement('div');
        contentElement.classList.add('node-content');

        // Use HTML content if available
        if (node.data.content) {
          contentElement.innerHTML = node.data.content;
        } else {
          contentElement.textContent = nodeId;
        }

        // Setup links to prevent default behavior and add visual indicators
        const links = contentElement.querySelectorAll('.zui-link');
        links.forEach((link) => {
          link.addEventListener('click', (e) => {
            e.preventDefault();
          });

          // Add visual indicator showing which node this links to
          const targetId = link.dataset.target;
          if (targetId) {
            link.title = `Links to: ${targetId}`;

            // Add text label to show relationship
            const linkLabel = document.createElement('div');
            linkLabel.style.position = 'absolute';
            linkLabel.style.bottom = '5px';
            linkLabel.style.right = '5px';
            linkLabel.style.fontSize = '9px';
            linkLabel.style.color = '#000';
            linkLabel.style.fontWeight = 'bold';
            linkLabel.style.backgroundColor = 'rgba(255,255,255,0.7)';
            linkLabel.style.padding = '1px 3px';
            linkLabel.style.borderRadius = '3px';
            linkLabel.textContent = `→ ${targetId}`;
            link.appendChild(linkLabel);
          }
        });

        nodeElement.appendChild(contentElement);
        return nodeElement;
      }

      /**
       * Calculates relative position of a link within its parent node
       * @param {HTMLElement} linkElement - The link element
       * @param {HTMLElement} nodeElement - The parent node element
       * @returns {Object} - The relative position and size data
       */
      function getLinkPosition(linkElement, nodeElement) {
        const nodeRect = nodeElement.getBoundingClientRect();
        const linkRect = linkElement.getBoundingClientRect();

        // Calculate relative position (0-1) within the node
        const x = (linkRect.left + linkRect.width / 2 - nodeRect.left) / nodeRect.width;
        const y = (linkRect.top + linkRect.height / 2 - nodeRect.top) / nodeRect.height;

        // Calculate relative size (0-1) compared to the node
        const width = linkRect.width / nodeRect.width;
        const height = linkRect.height / nodeRect.height;

        return { x, y, width, height };
      }

      /**
       * Converts link position to a transform matrix
       * @param {Object} linkPosition - The relative position and size data
       * @returns {DOMMatrix} - The resulting transform matrix
       */
      function linkPositionToTransform(linkPosition) {
        // Calculate the scale factor to make the target node exactly match the link size
        // We need to scale the node (NODE_WIDTH x NODE_HEIGHT) to match the link's dimensions
        const scaleX = linkPosition.width;
        const scaleY = linkPosition.height;

        // The link's center position in the node's coordinate system
        // Convert from relative coordinates (where linkPosition.x,linkPosition.y is the relative center)
        // to the coordinate system of the source node (where 0,0 is center)
        const translateX = (linkPosition.x - 0.5) * NODE_WIDTH;
        const translateY = (linkPosition.y - 0.5) * NODE_HEIGHT;

        // Create the transform matrix
        // First translate to position, then scale to match the link's size
        return new DOMMatrix().translate(translateX, translateY).scale(scaleX, scaleY);
      }

      // Setup temporary DOM to find links and build the edge map
      function buildEdgesFromLinks() {
        // Create a temporary container
        const tempContainer = document.createElement('div');
        tempContainer.style.position = 'absolute';
        tempContainer.style.visibility = 'hidden';
        tempContainer.style['pointer-events'] = 'none';
        document.body.appendChild(tempContainer);

        // Generate the edges array
        const edges = [];
        const renderedNodes = {};

        // First, create a DOM element for each node
        for (const node of nodesArray) {
          const nodeElement = document.createElement('div');
          nodeElement.classList.add('node');
          nodeElement.style.width = `${NODE_WIDTH}px`;
          nodeElement.style.height = `${NODE_HEIGHT}px`;

          const contentElement = document.createElement('div');
          contentElement.classList.add('node-content');
          contentElement.innerHTML = node.data.content;

          nodeElement.appendChild(contentElement);
          tempContainer.appendChild(nodeElement);
          renderedNodes[node.id] = nodeElement;
        }

        // Force layout calculation
        void tempContainer.offsetHeight;

        console.log('Building edges from links...');

        // Now find all links and calculate their positions
        for (const [nodeId, nodeElement] of Object.entries(renderedNodes)) {
          const links = nodeElement.querySelectorAll('.zui-link');
          console.log(`Node ${nodeId} has ${links.length} links`);

          links.forEach((link) => {
            const targetId = link.dataset.target;
            if (!targetId || !renderedNodes[targetId]) return;

            // Get the link's position relative to its parent node
            const linkPosition = getLinkPosition(link, nodeElement);
            console.log(`Link from ${nodeId} to ${targetId} at position:`, linkPosition);

            // Convert to a transform matrix
            const transform = linkPositionToTransform(linkPosition);
            console.log(`Transform for ${nodeId} → ${targetId}:`, formatTransform(transform));

            // Add to edges array
            edges.push({
              source: nodeId,
              target: targetId,
              transform,
            });
          });
        }

        // Clean up
        document.body.removeChild(tempContainer);

        console.log(`Built ${edges.length} edges total`);
        return edges;
      }

      // First, build edges from links in node content
      const edgesArray = buildEdgesFromLinks();

      const MAX_VISIBLE_NODES = 20;
      const container = document.getElementById('zui-container');
      const debugInfo = document.getElementById('debug-info');
      const visibleNodesInfo = document.getElementById('visible-nodes');

      // Create the floating origin graph with our nodes and edges
      const graph = new FloatingOriginGraph(nodesArray, edgesArray, 'nodeA');

      // Define zoom threshold callbacks
      function shouldZoomInToNextNode(graph, containerWidth, containerHeight, nextNodeId) {
        const nextNode = graph.nodes[nextNodeId];
        if (!nextNode) return false;

        // Get the transform from reference node to next node
        const nextNodeTransform = graph.getAccumulatedTransform(nextNodeId);
        if (!nextNodeTransform) return false;

        // Calculate effective transform from combined viewport and node transform
        const combinedTransform = graph.viewportTransform.multiply(nextNodeTransform);

        // Check if screen is completely covered by the node
        return isScreenCoveredByRectangle(
          -NODE_WIDTH / 2,
          -NODE_HEIGHT / 2,
          NODE_WIDTH,
          NODE_HEIGHT,
          combinedTransform,
          containerWidth,
          containerHeight,
        );
      }

      function shouldZoomOutToPrevNode(graph, containerWidth, containerHeight, prevNodeId) {
        const currentNode = graph.referenceNode;
        if (!currentNode) return false;

        // For zooming out, we check if the current reference node no longer covers the screen
        return !isScreenCoveredByRectangle(
          -NODE_WIDTH / 2,
          -NODE_HEIGHT / 2,
          NODE_WIDTH,
          NODE_HEIGHT,
          graph.viewportTransform,
          containerWidth,
          containerHeight,
        );
      }

      /**
       * Checks if a rectangle completely covers the screen, even when transformed (rotated/scaled)
       * @param rectX - The x coordinate of the top-left of the rectangle (in its own coordinate system)
       * @param rectY - The y coordinate of the top-left of the rectangle (in its own coordinate system)
       * @param width - The width of the rectangle
       * @param height - The height of the rectangle
       * @param transform - The transformation to apply to the rectangle
       * @param containerWidth - The width of the container
       * @param containerHeight - The height of the container
       * @returns True if the rectangle completely covers the screen
       */
      function isScreenCoveredByRectangle(rectX, rectY, width, height, transform, containerWidth, containerHeight) {
        // We'll check multiple points along the screen edges to see if they're all inside the transformed rectangle
        // For better accuracy, we sample more points for larger screens
        const numPointsToCheck = Math.max(5, Math.min(20, Math.floor(Math.max(containerWidth, containerHeight) / 50)));

        // Create test points along the screen edges and interior
        const testPoints = [];

        // Add the four corners of the screen
        testPoints.push({ x: 0, y: 0 }); // Top-left
        testPoints.push({ x: containerWidth, y: 0 }); // Top-right
        testPoints.push({ x: containerWidth, y: containerHeight }); // Bottom-right
        testPoints.push({ x: 0, y: containerHeight }); // Bottom-left

        // Add points along the edges of the screen
        for (let i = 1; i < numPointsToCheck - 1; i++) {
          const t = i / (numPointsToCheck - 1);
          // Top edge
          testPoints.push({ x: t * containerWidth, y: 0 });
          // Right edge
          testPoints.push({ x: containerWidth, y: t * containerHeight });
          // Bottom edge
          testPoints.push({ x: (1 - t) * containerWidth, y: containerHeight });
          // Left edge
          testPoints.push({ x: 0, y: (1 - t) * containerHeight });
        }

        // Add some interior points
        for (let i = 1; i < numPointsToCheck - 1; i++) {
          for (let j = 1; j < numPointsToCheck - 1; j++) {
            const x = (i / (numPointsToCheck - 1)) * containerWidth;
            const y = (j / (numPointsToCheck - 1)) * containerHeight;
            testPoints.push({ x, y });
          }
        }

        // Calculate the corners of the rectangle in its local coordinate system
        const rectCorners = [
          { x: rectX, y: rectY }, // Top-left
          { x: rectX + width, y: rectY }, // Top-right
          { x: rectX + width, y: rectY + height }, // Bottom-right
          { x: rectX, y: rectY + height }, // Bottom-left
        ];

        // Transform the rectangle corners to screen space
        const transformedRectCorners = rectCorners.map((corner) => {
          const pt = new DOMPoint(corner.x, corner.y);
          const transformedPt = pt.matrixTransform(transform);
          return {
            x: transformedPt.x + containerWidth / 2,
            y: transformedPt.y + containerHeight / 2,
          };
        });

        // Verify that all test points are inside the transformed rectangle
        for (const point of testPoints) {
          if (!isPointInPolygon(point, transformedRectCorners)) {
            return false;
          }
        }

        return true;
      }

      /**
       * Checks if a point is inside a polygon using the ray casting algorithm
       * @param point - The point to check
       * @param polygon - Array of points forming the polygon
       * @returns True if the point is inside the polygon
       */
      function isPointInPolygon(point, polygon) {
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
          const xi = polygon[i].x,
            yi = polygon[i].y;
          const xj = polygon[j].x,
            yj = polygon[j].y;

          const intersect = yi > point.y !== yj > point.y && point.x < ((xj - xi) * (point.y - yi)) / (yj - yi) + xi;
          if (intersect) inside = !inside;
        }
        return inside;
      }

      // Function to update the DOM based on the current graph state
      function updateDOM() {
        // Get container dimensions for centering
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;

        // Clear the container
        container.innerHTML = '';

        // Track visible nodes for debugging
        const visibleNodeIds = [];

        // Counter for generating unique instance IDs
        let instanceCounter = 0;

        // Process all visible nodes
        for (const { nodeId, node, transform } of graph.getVisibleNodesWithTransforms(MAX_VISIBLE_NODES)) {
          // Create a unique instance ID for this occurrence of the node
          const instanceId = instanceCounter++;

          // Create a new DOM element for this instance of the node
          const nodeElement = createNodeElement(nodeId, instanceId);
          if (!nodeElement) continue;

          // Add to container
          container.appendChild(nodeElement);

          // Track for debugging
          visibleNodeIds.push(`${nodeId}:${instanceId}`);

          // Combine viewport transform with the node's transform
          const combinedTransform = graph.viewportTransform.multiply(transform);

          // Calculate the position in the container
          // In FloatingOriginGraph, nodes are positioned at the center of the container
          const translateX = containerWidth / 2 + combinedTransform.e;
          const translateY = containerHeight / 2 + combinedTransform.f;

          // Extract scale and rotation from the transform
          const scale = combinedTransform.a; // Assuming uniform scaling

          // Create a CSS transform
          // The order is important: first translate to center, then apply the transform
          const cssTransform = `
            translate(-50%, -50%)
            translate(${translateX}px, ${translateY}px)
            scale(${scale})
          `;

          // Apply the transform
          nodeElement.style.transform = cssTransform;

          // Highlight the reference node
          if (nodeId === graph.referenceNodeId && transform.a === 1 && transform.d === 1) {
            nodeElement.style.border = '4px solid yellow';
            debugInfo.textContent = `Reference: ${nodeId}, ${formatTransform(combinedTransform)}`;
          }
        }

        // Update visible nodes info
        visibleNodesInfo.textContent = `Visible nodes: ${visibleNodeIds.join(', ')}`;

        // Update reference node info display
        document.getElementById('reference-node-info').textContent = `coordinate frame: ${graph.referenceNodeId}`;
      }

      // Handle window resizing
      function handleResize() {
        updateDOM();
      }

      // Pan handling
      let isDragging = false;
      let lastX = 0;
      let lastY = 0;

      // Add mouse position tracking
      let currentMouseX = container.clientWidth / 2;
      let currentMouseY = container.clientHeight / 2;

      function setupEventListeners() {
        // Mouse down for panning
        container.addEventListener('mousedown', (e) => {
          // Prevent zooming when clicking on links
          if (e.target.classList.contains('zui-link')) {
            e.preventDefault();
            return;
          }

          isDragging = true;
          lastX = e.clientX;
          lastY = e.clientY;
          container.style.cursor = 'grabbing';
        });

        // Mouse move for panning and tracking
        container.addEventListener('mousemove', (e) => {
          currentMouseX = e.clientX;
          currentMouseY = e.clientY;

          if (isDragging) {
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;

            // Update viewport transform for panning
            graph.pan(dx, dy);

            lastX = e.clientX;
            lastY = e.clientY;

            updateDOM();
          }
        });

        // Mouse up to end panning
        window.addEventListener('mouseup', () => {
          if (isDragging) {
            isDragging = false;
            container.style.cursor = 'default';
          }
        });

        // Wheel for zooming
        container.addEventListener(
          'wheel',
          (e) => {
            e.preventDefault();

            // Calculate zoom factor
            const zoomFactor = e.deltaY > 0 ? 0.95 : 1.05;

            // Get mouse position relative to container center
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            const mouseX = e.clientX - containerWidth / 2;
            const mouseY = e.clientY - containerHeight / 2;

            // Apply zoom centered on mouse position and check if reference node changed
            const referenceChanged = graph.zoomAtPoint(
              mouseX,
              mouseY,
              zoomFactor,
              containerWidth,
              containerHeight,
              shouldZoomInToNextNode,
              shouldZoomOutToPrevNode,
            );

            updateDOM();
          },
          { passive: false },
        );

        // Keyboard events for continuous zooming
        window.addEventListener('keydown', (e) => {
          if (e.shiftKey && !e.altKey && !isShiftZooming) {
            isShiftZooming = true;
            startContinuousZoom(true);
          } else if (e.shiftKey && e.altKey && !isAltShiftZooming) {
            isAltShiftZooming = true;
            startContinuousZoom(false);
          }
        });

        window.addEventListener('keyup', (e) => {
          if (!e.shiftKey || (isAltShiftZooming && !e.altKey)) {
            isShiftZooming = false;
            isAltShiftZooming = false;
            stopContinuousZoom();
          }
        });

        // Window resize handler
        window.addEventListener('resize', handleResize);
      }

      // Continuous zoom variables and functions
      let isShiftZooming = false;
      let isAltShiftZooming = false;
      let zoomAnimationId = null;
      let isZooming = false;
      let zoomDirection = 1;

      function startContinuousZoom(zoomIn) {
        stopContinuousZoom(); // Cancel any existing animation

        isZooming = true;
        zoomDirection = zoomIn ? 1 : -1;

        // Start the animation loop
        animateZoom();
      }

      function animateZoom() {
        if (!isZooming) return;

        // Calculate zoom factor based on direction
        const zoomFactor = zoomDirection > 0 ? 1.02 : 0.98;

        // Get mouse position relative to container center
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        const mouseX = currentMouseX - containerWidth / 2;
        const mouseY = currentMouseY - containerHeight / 2;

        // Apply zoom centered on mouse position and check if reference node changed
        const referenceChanged = graph.zoomAtPoint(
          mouseX,
          mouseY,
          zoomFactor,
          containerWidth,
          containerHeight,
          shouldZoomInToNextNode,
          shouldZoomOutToPrevNode,
        );

        updateDOM();

        // Continue the animation loop
        zoomAnimationId = requestAnimationFrame(animateZoom);
      }

      function stopContinuousZoom() {
        isZooming = false;
        if (zoomAnimationId) {
          cancelAnimationFrame(zoomAnimationId);
          zoomAnimationId = null;
        }
      }

      // Debug info formatter for transforms
      function formatTransform(transform) {
        return `[Scale: ${transform.a.toFixed(2)} × ${transform.d.toFixed(2)}, Pos: (${transform.e.toFixed(0)}, ${transform.f.toFixed(0)})]`;
      }

      // Initialize and start the application
      function init() {
        setupEventListeners();
        updateDOM();

        // Log initial state
        console.log('Initial graph state:', {
          referenceNodeId: graph.referenceNodeId,
          viewportTransform: graph.viewportTransform,
          nodes: graph.nodesArray.length,
        });

        // Log the edges with their transforms
        console.log('Edges with their transforms:', edgesArray);
      }

      // Start the application
      init();
    </script>
  </body>
</html>
