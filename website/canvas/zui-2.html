<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Infinite ZUI with RelativeScaleTree</title>
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        overflow: hidden;
        background: #f9f9f9;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      }

      #info-container {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: white;
        padding: 8px 10px;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        z-index: 2000;
        max-width: 300px;
        font-size: 12px;
        line-height: 1.4;

        & > div:first-child {
          font-weight: bold;
        }
      }

      #canvas-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      canvas {
        position: absolute;
        top: 0;
        left: 0;
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <div id="info-container">
      <div>Infinite ZUI with RelativeScaleTree</div>
      <div>A zoomable UI with infinite tree-like structure using the RelativeScaleTree implementation.</div>
      <div>Scroll to zoom, drag to pan.</div>
    </div>

    <div id="canvas-container">
      <canvas id="canvas"></canvas>
    </div>

    <script type="module">
      // Canvas setup
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      // Viewport state
      const viewport = {
        scale: 1,
        offsetX: 0,
        offsetY: 0,
        isDragging: false,
        lastX: 0,
        lastY: 0,
      };

      // Test rectangle in world coordinates
      const testRect = {
        x: 0,
        y: 0,
        width: 200,
        height: 150,
        color: '#3498db',
      };

      // Resize handler
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        draw();
      }

      // Transform from world to screen coordinates
      function worldToScreen(x, y) {
        return {
          x: x * viewport.scale + viewport.offsetX,
          y: y * viewport.scale + viewport.offsetY,
        };
      }

      // Transform from screen to world coordinates
      function screenToWorld(x, y) {
        return {
          x: (x - viewport.offsetX) / viewport.scale,
          y: (y - viewport.offsetY) / viewport.scale,
        };
      }

      // Draw function
      function draw() {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw test rectangle
        const { x, y } = worldToScreen(testRect.x, testRect.y);
        ctx.fillStyle = testRect.color;
        ctx.fillRect(x, y, testRect.width * viewport.scale, testRect.height * viewport.scale);

        // Draw rectangle border
        ctx.strokeStyle = '#2980b9';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, testRect.width * viewport.scale, testRect.height * viewport.scale);
      }

      // Event handlers
      function handlePointerDown(e) {
        viewport.isDragging = true;
        viewport.lastX = e.clientX;
        viewport.lastY = e.clientY;
      }

      function handlePointerMove(e) {
        if (!viewport.isDragging) return;

        const deltaX = e.clientX - viewport.lastX;
        const deltaY = e.clientY - viewport.lastY;

        viewport.offsetX += deltaX;
        viewport.offsetY += deltaY;

        viewport.lastX = e.clientX;
        viewport.lastY = e.clientY;

        draw();
      }

      function handlePointerUp() {
        viewport.isDragging = false;
      }

      function handleWheel(e) {
        e.preventDefault();

        // Get mouse position in world coordinates before zoom
        const mouseX = e.clientX;
        const mouseY = e.clientY;
        const worldPos = screenToWorld(mouseX, mouseY);

        // Adjust scale based on wheel direction with a smaller zoom factor
        const zoomSensitivity = 0.03; // Reduced from the implicit 0.1/0.1 in the original
        const zoomFactor = e.deltaY < 0 ? 1 + zoomSensitivity : 1 - zoomSensitivity;
        viewport.scale *= zoomFactor;

        // Limit zoom levels if needed
        viewport.scale = Math.min(Math.max(viewport.scale, 0.1), 10);

        // Adjust offset to zoom toward mouse position
        viewport.offsetX = mouseX - worldPos.x * viewport.scale;
        viewport.offsetY = mouseY - worldPos.y * viewport.scale;

        draw();
      }

      // Initialize
      function init() {
        resizeCanvas();

        // Center the viewport initially
        viewport.offsetX = canvas.width / 2;
        viewport.offsetY = canvas.height / 2;

        // Add event listeners
        canvas.addEventListener('pointerdown', handlePointerDown);
        window.addEventListener('pointermove', handlePointerMove);
        window.addEventListener('pointerup', handlePointerUp);
        canvas.addEventListener('wheel', handleWheel, { passive: false });
        window.addEventListener('resize', resizeCanvas);

        draw();
      }

      // Start the application
      init();
    </script>
  </body>
</html>
