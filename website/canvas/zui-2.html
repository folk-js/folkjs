<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Infinite ZUI with ZoomableGraph</title>
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        overflow: hidden;
        background: #f9f9f9;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      }

      #info-container {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: white;
        padding: 8px 10px;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        z-index: 2000;
        max-width: 300px;
        font-size: 12px;
        line-height: 1.4;

        & > div:first-child {
          font-weight: bold;
        }
      }

      #canvas-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      canvas {
        position: absolute;
        top: 0;
        left: 0;
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <div id="info-container">
      <div>Infinite ZUI with ZoomableGraph</div>
      <div>A zoomable UI using the ZoomableGraph implementation with a single node.</div>
      <div>Scroll to zoom, drag to pan.</div>
    </div>

    <div id="canvas-container">
      <canvas id="canvas"></canvas>
    </div>

    <script type="module">
      // Try a different import approach
      import * as ZoomableGraphModule from '@labs/ZoomableGraph.ts';

      // Log the imported module to see what's available
      console.log('Imported module:', ZoomableGraphModule);

      // Use the ZoomableGraph class from the module
      const ZoomableGraph = ZoomableGraphModule.ZoomableGraph;

      // Canvas setup
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      // Create nodes for the graph
      const rootNode = {
        id: 'root',
        data: {
          color: '#3498db',
        },
      };

      const secondNode = {
        id: 'node2',
        data: {
          color: '#e74c3c',
        },
      };

      let graph;

      // Event handlers
      function handlePointerDown(e) {
        canvas.setPointerCapture(e.pointerId);
        lastX = e.clientX;
        lastY = e.clientY;
        isDragging = true;
      }

      function handlePointerMove(e) {
        if (!isDragging) return;

        const deltaX = e.clientX - lastX;
        const deltaY = e.clientY - lastY;

        // Use ZoomableGraph's pan method
        graph.pan(deltaX, deltaY);

        lastX = e.clientX;
        lastY = e.clientY;

        draw();
      }

      function handlePointerUp(e) {
        isDragging = false;
        canvas.releasePointerCapture(e.pointerId);
      }

      function handleWheel(e) {
        e.preventDefault();

        // Calculate zoom factor based on wheel direction
        const zoomSensitivity = 0.03;
        const zoomFactor = e.deltaY < 0 ? 1 + zoomSensitivity : 1 - zoomSensitivity;

        // Use ZoomableGraph's zoom method with the mouse position as focal point
        graph.zoom(zoomFactor, e.clientX, e.clientY);

        draw();
      }

      // Draw function
      function draw() {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        try {
          if (!graph) {
            console.error('Graph is undefined in draw function');
            return;
          }

          // Get the current view state
          const viewState = graph.getViewState();

          // Base size for nodes
          const nodeBaseSize = 200;

          // Draw the reference frame node first
          const refFrameId = viewState.referenceFrameId;
          const refFrameNode = graph.getNode(refFrameId);
          const refFramePosition = graph.getNodeViewportPosition(refFrameId);

          if (refFramePosition.visible && refFrameNode) {
            // For the reference frame node, we need to apply a base size
            const x = refFramePosition.x;
            const y = refFramePosition.y;
            const width = refFramePosition.width * nodeBaseSize;
            const height = refFramePosition.height * nodeBaseSize;

            // Draw the node
            ctx.fillStyle = refFrameNode.data.color;
            ctx.fillRect(x, y, width, height);

            // Draw border
            ctx.strokeStyle = '#2980b9';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, width, height);

            // Draw node ID text
            ctx.fillStyle = 'white';
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(refFrameNode.id, x + width / 2, y + height / 2);

            // Draw position indicator
            ctx.fillStyle = 'black';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText(`(${x.toFixed(0)}, ${y.toFixed(0)})`, x + width / 2, y - 5);
          }

          // Get connected nodes from the current reference frame
          const connectedNodes = graph.getConnectedNodes();
          console.log('Connected nodes:', connectedNodes);

          // Draw all connected nodes
          for (const { node, position } of connectedNodes) {
            if (position.visible) {
              // Apply the base size to make nodes larger
              const x = position.x;
              const y = position.y;
              const width = position.width * nodeBaseSize;
              const height = position.height * nodeBaseSize;

              ctx.fillStyle = node.data.color;
              ctx.fillRect(x, y, width, height);

              // Draw border
              ctx.strokeStyle = '#2980b9';
              ctx.lineWidth = 2;
              ctx.strokeRect(x, y, width, height);

              // Draw node ID text
              ctx.fillStyle = 'white';
              ctx.font = '16px sans-serif';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(node.id, x + width / 2, y + height / 2);

              // Draw position indicator
              ctx.fillStyle = 'black';
              ctx.font = '12px sans-serif';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'bottom';
              ctx.fillText(`(${x.toFixed(0)}, ${y.toFixed(0)})`, x + width / 2, y - 5);
            }
          }

          // Display current view state for debugging
          ctx.fillStyle = 'black';
          ctx.font = '12px sans-serif';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'top';
          ctx.fillText(`Reference Frame: ${viewState.referenceFrameId}`, 10, canvas.height - 60);
          ctx.fillText(`Scale: ${viewState.viewportScale.toFixed(2)}`, 10, canvas.height - 40);
          ctx.fillText(
            `Offset: (${viewState.viewportOffset.x.toFixed(2)}, ${viewState.viewportOffset.y.toFixed(2)})`,
            10,
            canvas.height - 20,
          );
        } catch (error) {
          console.error('Error in draw function:', error);
        }
      }

      // Resize handler
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Update the graph's viewport dimensions
        if (graph) {
          graph.setViewportDimensions(canvas.width, canvas.height);
          draw();
        } else {
          console.log('Graph not initialized yet in resizeCanvas');
        }
      }

      // Initialize
      let isDragging = false;
      let lastX = 0;
      let lastY = 0;

      function init() {
        // Set up canvas dimensions first
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        console.log('Canvas dimensions:', canvas.width, canvas.height);

        // Initialize the graph with viewport dimensions
        try {
          console.log('Creating ZoomableGraph instance...');
          console.log('Root node:', rootNode);

          // Initialize with the root node
          graph = new ZoomableGraph(rootNode, canvas.width, canvas.height);
          console.log('ZoomableGraph instance created successfully:', graph);

          // Add the second node
          graph.addNode(secondNode);

          // Add an edge from root to the second node
          // The bounds define how the target node appears when viewed from the source node
          // x, y: position (relative to the source node)
          // width, height: size (relative to the source node)
          graph.addEdge('root', 'node2', {
            x: 0, // Position to the right of the root node
            y: 0, // Position slightly below the root node
            width: 0.5, // Half the size of the root node
            height: 1, // Half the size of the root node
          });

          // Only draw after graph is successfully created
          draw();
        } catch (error) {
          console.error('Error creating ZoomableGraph instance:', error);
        }

        // Add event listeners
        canvas.addEventListener('pointerdown', handlePointerDown);
        window.addEventListener('pointermove', handlePointerMove);
        window.addEventListener('pointerup', handlePointerUp);
        canvas.addEventListener('wheel', handleWheel, { passive: false });
        window.addEventListener('resize', resizeCanvas);
      }

      // Start the application
      init();
    </script>
  </body>
</html>
