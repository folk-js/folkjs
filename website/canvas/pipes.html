<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Recursive:slnt,wght,CASL,CRSV,MONO@-15..0,300..1000,0..1,0..1,0..1&display=swap"
      rel="stylesheet"
    />
    <title>Folk Pipes</title>
    <style>
      body {
        font-family: 'Recursive', Courier, monospace;
        font-variation-settings:
          'slnt' 0,
          'wght' 400,
          'CASL' 1,
          'CRSV' 0,
          'MONO' 0;
        max-width: 900px;
        margin: 1rem auto;
        padding: 1.5rem;
        line-height: 1.5;
        background: #f5f5f5;
      }

      h1 {
        font-variation-settings:
          'CASL' 1,
          'MONO' 1;
        text-align: center;
        margin-bottom: 1.5rem;
        font-size: 2rem;
      }

      h2 {
        font-weight: 800;
        font-variation-settings: 'wght' 800;
        margin: 2rem 0 0.75rem;
        font-size: 1.4rem;
      }

      h3 {
        font-weight: 600;
        margin: 1.5rem 0 0.5rem;
        font-size: 1.2rem;
      }

      p {
        margin-bottom: 0.75rem;
        color: #666;
        font-size: 0.9rem;
      }

      section {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        margin: 0.75rem 0 1.5rem;
      }

      .horizontal {
        flex-direction: row;
        align-items: center;
        flex-wrap: wrap;
      }

      .horizontal > *:not(folk-pipe) {
        min-width: 200px;
        flex: 1;
      }

      input,
      textarea,
      select {
        padding: 0.4rem;
        border: 1px solid #ccc;
        border-radius: 3px;
        font: inherit;
        font-size: 0.9rem;
      }

      pre,
      code,
      [contenteditable] {
        background: #f8f8f8;
        padding: 0.4rem;
        border-radius: 3px;
        border: 1px solid #ddd;
        min-height: 1.5rem;
        font-size: 0.85rem;
      }

      script[type='hash-module'] {
        display: block !important;
        background: #1e1e1e;
        color: #f1f1f1;
        border: 2px solid #007acc;
        border-radius: 4px;
        padding: 0.75rem;
        font-family: 'Recursive', Courier, monospace;
        font-variation-settings: 'MONO' 1;
        font-size: 0.8rem;
        white-space: pre;
        min-height: 3rem;
        outline: none;
        overflow-x: auto;
        min-width: 250px;
        max-width: 100%;
        position: relative;
        transition: all 0.3s ease;
      }

      script[type='hash-module']:focus {
        border-color: #00d4ff;
        box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.3);
      }

      script[type='hash-module']:before {
        content: 'üìú #' attr(id) ' ‚ñº';
        display: block;
        font-size: 0.7rem;
        color: #007acc;
        margin-bottom: 0.5rem;
        font-weight: bold;
        cursor: pointer;
        user-select: none;
        padding: 0.25rem;
        margin: -0.25rem -0.25rem 0.5rem -0.25rem;
        border-radius: 3px;
        transition: background-color 0.2s ease;
      }

      script[type='hash-module']:before:hover {
        background-color: rgba(0, 122, 204, 0.1);
      }

      script[type='hash-module'].collapsed {
        min-height: auto;
        height: 2.5rem;
        overflow: hidden;
        padding: 0.5rem 1rem;
      }

      script[type='hash-module'].collapsed:before {
        content: 'üìú #' attr(id) ' ‚ñ∂ (click to expand)';
        margin-bottom: 0;
      }

      script[type='hash-module']:after {
        content: '‚ñ∂Ô∏è Run';
        position: absolute;
        top: 0.5rem;
        right: 0.5rem;
        font-size: 0.7rem;
        background: #007acc;
        color: white;
        padding: 0.25rem 0.5rem;
        border-radius: 3px;
        cursor: pointer;
        opacity: 0;
        transition: opacity 0.2s ease;
        pointer-events: none;
      }

      script[type='hash-module']:hover:after {
        opacity: 1;
        pointer-events: auto;
      }

      script[type='hash-module'].running:after {
        content: '‚è≥ Running...';
        background: #ff9500;
        opacity: 1;
      }

      button {
        background: #007acc;
        color: white;
        border: none;
        padding: 0.4rem 0.8rem;
        border-radius: 3px;
        cursor: pointer;
        font: inherit;
        font-size: 0.85rem;
        margin: 0.2rem;
      }

      button:hover {
        background: #005a9c;
      }

      canvas {
        border: 2px solid #007acc;
        border-radius: 3px;
        cursor: crosshair;
        background: white;
        display: block;
      }

      img {
        max-width: 180px;
        max-height: 135px;
        border: 1px solid #ddd;
        border-radius: 3px;
      }

      table {
        font-size: 0.85rem;
      }

      label {
        font-size: 0.9rem;
        font-weight: 500;
      }
    </style>
  </head>
  <body>
    <h1>Folk Pipes</h1>
    <p>The <code>&lt;folk-pipe&gt;</code> element creates reactive data flows between DOM elements.</p>

    <h2>Core Concept: Script Transform</h2>
    <p>The fundamental pattern: Input ‚Üí Script Transform ‚Üí Output</p>
    <section>
      <input type="text" placeholder="Enter some text..." value="hello world" />
      <folk-pipe></folk-pipe>
      <script type="hash-module" id="textTransform" contenteditable>
        export default function transform(input) {
          const emojis = ['üöÄ', '‚ú®', 'üéâ', 'üî•', 'üí´', '‚≠ê', 'üåü', 'üí•', 'üéä', 'üéà'];

          function getRandomEmojis() {
            const count = 2 + Math.floor(Math.random() * 2); // 2-3 emojis
            return Array.from({length: count}, () =>
              emojis[Math.floor(Math.random() * emojis.length)]
            ).join(' ');
          }

          const words = input.toUpperCase().split(' ');
          let result = words[0] || '';

          for (let i = 1; i < words.length; i++) {
            result += ` ${getRandomEmojis()} ${words[i]}`;
          }

          return result + ` ${getRandomEmojis()}`;
        }
      </script>
      <folk-pipe></folk-pipe>
      <pre></pre>
    </section>

    <h2>Interactive Controls</h2>
    <p>Various input controls can drive data flows.</p>
    <section>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem">
        <div>
          <label for="volume-slider">Volume:</label>
          <input type="range" id="volume-slider" min="0" max="100" value="75" />
          <folk-pipe></folk-pipe>
          <script type="hash-module" id="volumeProcessor" contenteditable>
            export default function processVolume(value) {
              const vol = parseInt(value);
              const bars = Math.floor(vol / 10);
              const visual = '‚ñà'.repeat(bars) + '‚ñë'.repeat(10 - bars);
              return `üîä ${visual} ${vol}%`;
            }
          </script>
          <folk-pipe></folk-pipe>
          <output></output>
        </div>
        <div>
          <label for="color-select">Color:</label>
          <select id="color-select">
            <option value="#ff0000">üî¥ Red</option>
            <option value="#00ff00">üü¢ Green</option>
            <option value="#0000ff">üîµ Blue</option>
            <option value="#ffff00">üü° Yellow</option>
          </select>
          <folk-pipe></folk-pipe>
          <div
            style="
              width: 100px;
              height: 50px;
              border: 2px solid #333;
              background: #ff0000;
              color: white;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 0.8rem;
            "
            >üî¥ Red</div
          >
        </div>
      </div>
    </section>

    <h2>Multi-Step Pipelines</h2>
    <p>Chain multiple transforms together for complex data flows.</p>
    <section>
      <textarea rows="2">Alice,25 Bob,30 Carol,28</textarea>
      <folk-pipe></folk-pipe>
      <script type="hash-module" id="csvSplitter" contenteditable>
        export default function parseSimpleCSV(input) {
          return input.split(' ').map(person => {
            const [name, age] = person.split(',');
            return { name, age: parseInt(age) };
          });
        }
      </script>
      <folk-pipe></folk-pipe>
      <script type="hash-module" id="ageAnalyzer" contenteditable>
                export default function analyzeAges(people) {
                  const totalAge = people.reduce((sum, p) => sum + p.age, 0);
                  const avgAge = totalAge / people.length;
                  const oldest = people.reduce((max, p) => p.age > max.age ? p : max);

                  return `üë• ${people.length} people
        üéÇ Average age: ${avgAge.toFixed(1)}
        üëë Oldest: ${oldest.name} (${oldest.age})`;
                }
      </script>
      <folk-pipe></folk-pipe>
      <pre></pre>
    </section>

    <h2>Module Reuse</h2>
    <p>Hash modules can import and reuse each other using <code>import from '#moduleId'</code>.</p>
    <p>The <code>#mathUtils</code> module is defined above and provides reusable functions.</p>
    <section>
      <textarea rows="3">
Product A: 100,120,110,130
Product B: 80,90,85,95
Product C: 150,160,140,170</textarea
      >
      <folk-pipe></folk-pipe>
      <script type="hash-module" id="salesAnalyzer" contenteditable>
        import { average, formatPercent, formatCurrency } from '#mathUtils';

        export default function analyzeSales(input) {
          const lines = input.trim().split('\n');
          let results = 'üìä SALES ANALYSIS\n\n';

          lines.forEach(line => {
            const [product, salesStr] = line.split(': ');
            const sales = salesStr.split(',').map(Number);
            const avg = average(sales);
            const growth = (sales[sales.length - 1] - sales[0]) / sales[0];

            results += `${product}:\n`;
            results += `  üìà Average: ${formatCurrency(avg)}\n`;
            results += `  üöÄ Growth: ${formatPercent(growth)}\n\n`;
          });

          return results;
        }
      </script>
      <folk-pipe></folk-pipe>
      <pre></pre>
    </section>

    <h2>Form Data Processing</h2>
    <p>Forms pipe out key-value objects of all their fields.</p>
    <section>
      <form>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem">
          <div>
            <label>Name: <input type="text" name="name" value="Alice" /></label>
          </div>
          <div>
            <label>Age: <input type="number" name="age" value="25" /></label>
          </div>
          <div>
            <label>Email: <input type="email" name="email" value="alice@example.com" /></label>
          </div>
          <div>
            <label
              >Department:
              <select name="department">
                <option value="engineering">Engineering</option>
                <option value="design" selected>Design</option>
                <option value="marketing">Marketing</option>
              </select>
            </label>
          </div>
          <div>
            <label><input type="checkbox" name="remote" checked /> Remote Worker</label>
          </div>
          <div>
            <label><input type="checkbox" name="fulltime" checked /> Full Time</label>
          </div>
        </div>
      </form>
      <folk-pipe></folk-pipe>
      <script type="hash-module" id="formProcessor" contenteditable>
                export default function processEmployee(formData) {
                  const employee = {
                    ...formData,
                    status: formData.remote ? 'Remote' : 'On-site',
                    workType: formData.fulltime ? 'Full-time' : 'Part-time',
                    yearsToRetirement: Math.max(0, 65 - (formData.age || 0))
                  };

                  return `Employee Profile:
        üßë‚Äçüíº ${employee.name} (${employee.age} years old)
        üìß ${employee.email}
        üè¢ ${employee.department} department
        üíº ${employee.status}, ${employee.workType}
        üéØ ${employee.yearsToRetirement} years to retirement`;
                }
      </script>
      <folk-pipe></folk-pipe>
      <pre></pre>
    </section>

    <h2>Table Data Analysis</h2>
    <p>Tables pipe out 2D arrays that can be processed with scripts.</p>
    <section>
      <table border="1" style="border-collapse: collapse; width: 100%">
        <tr>
          <th>Product</th>
          <th>Q1 Sales</th>
          <th>Q2 Sales</th>
          <th>Q3 Sales</th>
          <th>Q4 Sales</th>
        </tr>
        <tr>
          <td contenteditable>Laptops</td>
          <td contenteditable>120</td>
          <td contenteditable>150</td>
          <td contenteditable>180</td>
          <td contenteditable>200</td>
        </tr>
        <tr>
          <td contenteditable>Phones</td>
          <td contenteditable>300</td>
          <td contenteditable>320</td>
          <td contenteditable>280</td>
          <td contenteditable>350</td>
        </tr>
        <tr>
          <td contenteditable>Tablets</td>
          <td contenteditable>80</td>
          <td contenteditable>90</td>
          <td contenteditable>70</td>
          <td contenteditable>85</td>
        </tr>
      </table>
      <folk-pipe></folk-pipe>
      <script type="hash-module" id="tableAnalyzer" contenteditable>
        export default function analyzeSales(tableData) {
          if (!Array.isArray(tableData) || tableData.length < 2) {
            return "No data to analyze";
          }

          const [headers, ...rows] = tableData;
          let analysis = "üìä SALES ANALYSIS\n\n";

          // Calculate totals for each product
          rows.forEach(row => {
            const [product, ...sales] = row;
            const numbers = sales.map(s => parseFloat(s) || 0);
            const total = numbers.reduce((sum, n) => sum + n, 0);
            const avg = total / numbers.length;
            const growth = numbers.length > 1 ?
              ((numbers[numbers.length - 1] - numbers[0]) / numbers[0] * 100).toFixed(1) : 0;

            analysis += `${product}:\n`;
            analysis += `  üìà Total: ${total} units\n`;
            analysis += `  üìä Average: ${avg.toFixed(1)} units/quarter\n`;
            analysis += `  üöÄ Growth: ${growth}%\n\n`;
          });

          // Calculate quarterly totals
          const quarterTotals = [];
          for (let i = 1; i < headers.length; i++) {
            const quarterTotal = rows.reduce((sum, row) => {
              return sum + (parseFloat(row[i]) || 0);
            }, 0);
            quarterTotals.push(quarterTotal);
            analysis += `${headers[i]}: ${quarterTotal} total units\n`;
          }

          return analysis;
        }
      </script>
      <folk-pipe></folk-pipe>
      <pre></pre>
    </section>

    <h2>Dynamic Table Generation</h2>
    <p>Generate tables from script data - they automatically resize to match the data.</p>
    <section>
      <button onclick="generateRandomData()">Generate Random Data</button>
      <folk-pipe></folk-pipe>
      <script type="hash-module" id="tableGenerator" contenteditable>
        export default function generateTableData(trigger) {
          const products = ['Laptops', 'Phones', 'Tablets', 'Monitors', 'Keyboards', 'Mice'];
          const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'];

          // Random number of products (2-6) and months (3-6)
          const numProducts = 2 + Math.floor(Math.random() * 5);
          const numMonths = 3 + Math.floor(Math.random() * 4);

          const selectedProducts = products.slice(0, numProducts);
          const selectedMonths = months.slice(0, numMonths);

          // Create header row
          const headers = ['Product', ...selectedMonths];

          // Create data rows
          const dataRows = selectedProducts.map(product => {
            const sales = selectedMonths.map(() =>
              Math.floor(Math.random() * 200) + 50
            );
            return [product, ...sales];
          });

          return [headers, ...dataRows];
        }
      </script>
      <folk-pipe></folk-pipe>
      <table border="1" style="border-collapse: collapse; width: 100%; background: #f9f9f9"></table>
    </section>

    <h2>Tests & Experiments</h2>
    <p>Advanced features and interactive demonstrations.</p>

    <h3>Canvas Drawing</h3>
    <p>Click and drag on the canvas to draw, pipe the result to an image.</p>
    <section>
      <canvas width="300" height="200"></canvas>
      <folk-pipe></folk-pipe>
      <img alt="Canvas output" />
      <button onclick="clearCanvas()">Clear Canvas</button>
    </section>

    <h3>Image URLs</h3>
    <section class="horizontal">
      <input type="url" placeholder="Image URL..." value="https://picsum.photos/200/150" />
      <folk-pipe></folk-pipe>
      <img alt="Piped image" />
    </section>

    <h3>Dynamic Connections</h3>
    <p>Insert elements between pipes to change connections dynamically.</p>
    <section>
      <input type="text" value="Source element" />
      <folk-pipe></folk-pipe>
      <div contenteditable>Original target</div>
      <div>
        <button onclick="insertBetween()">Insert Between</button>
        <button onclick="removeInserted()">Remove Inserted</button>
        <button onclick="testCurrentConnection()">Test Connection</button>
      </div>
    </section>

    <!-- Utility modules must be defined before boot loader -->
    <script type="hash-module" id="mathUtils">
      export function average(numbers) {
        return numbers.reduce((sum, n) => sum + n, 0) / numbers.length;
      }

      export function formatPercent(value) {
        return `${(value * 100).toFixed(1)}%`;
      }

      export function formatCurrency(value) {
        return `$${value.toLocaleString()}`;
      }

      export default { average, formatPercent, formatCurrency };
    </script>

    <!-- Hash module bootloader -->
    <script>
      console.log('üöÄ Starting hash module bootloader...');

      // Create import map for all hash modules
      const imports = {};
      const modules = document.querySelectorAll('script[type="hash-module"]');

      modules.forEach((module) => {
        if (module.id) {
          const blobUrl = URL.createObjectURL(new Blob([module.textContent || ''], { type: 'application/javascript' }));
          imports['#' + module.id] = blobUrl;
        }
      });

      if (Object.keys(imports).length > 0) {
        const importMap = document.createElement('script');
        importMap.type = 'importmap';
        importMap.textContent = JSON.stringify({ imports });
        document.head.appendChild(importMap);

        console.log('‚úÖ Hash modules ready:', Object.keys(imports));
      }

      // Signal that hash modules are ready
      window.hashModulesReady = true;
      window.hashModuleImports = imports;

      document.dispatchEvent(
        new CustomEvent('hash-modules-ready', {
          detail: { imports, moduleIds: Object.keys(imports) },
        }),
      );
    </script>

    <script type="module">
      import '@folkjs/labs/standalone/folk-pipe';

      // Canvas drawing functionality
      const canvas = document.querySelector('canvas');
      const ctx = canvas.getContext('2d');
      let isDrawing = false;

      ctx.strokeStyle = '#007acc';
      ctx.lineWidth = 3;
      ctx.lineCap = 'round';

      function startDrawing(e) {
        isDrawing = true;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        ctx.beginPath();
        ctx.moveTo(x, y);
      }

      function draw(e) {
        if (!isDrawing) return;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        ctx.lineTo(x, y);
        ctx.stroke();

        // Trigger pipe update
        canvas.dispatchEvent(new Event('change'));
      }

      function stopDrawing() {
        if (isDrawing) {
          isDrawing = false;
          ctx.beginPath();
        }
      }

      canvas.addEventListener('mousedown', startDrawing);
      canvas.addEventListener('mousemove', draw);
      canvas.addEventListener('mouseup', stopDrawing);
      canvas.addEventListener('mouseout', stopDrawing);

      // Touch support for mobile
      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousedown', {
          clientX: touch.clientX,
          clientY: touch.clientY,
        });
        canvas.dispatchEvent(mouseEvent);
      });

      canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousemove', {
          clientX: touch.clientX,
          clientY: touch.clientY,
        });
        canvas.dispatchEvent(mouseEvent);
      });

      canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        const mouseEvent = new MouseEvent('mouseup', {});
        canvas.dispatchEvent(mouseEvent);
      });

      window.clearCanvas = function () {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        canvas.dispatchEvent(new Event('change'));
      };

      // Script update trigger
      window.triggerScriptUpdate = function () {
        const scriptElement = document.querySelector('script[type="hash-module"]:last-of-type');
        if (scriptElement) {
          scriptElement.dispatchEvent(new Event('input'));
        }
      };

      // Test functions
      window.testChainedReactivity = function () {
        const textarea = document.querySelector('textarea[rows="2"]');
        const messages = [
          'Programmatic change at: ' + new Date().toLocaleTimeString(),
          'Testing reactive pipes...',
          'This flows through all elements!',
        ];

        let index = 0;
        const interval = setInterval(() => {
          if (index < messages.length) {
            textarea.value = messages[index];
            console.log(`Set textarea: "${messages[index]}"`);
            index++;
          } else {
            clearInterval(interval);
          }
        }, 1500);
      };

      // Dynamic DOM manipulation
      let insertedElements = [];

      window.insertBetween = function () {
        const lastSection = document.querySelector('section:last-of-type');
        const pipe = lastSection.querySelector('folk-pipe');

        const newElement = document.createElement('pre');
        newElement.textContent = `New target ${insertedElements.length + 1}`;
        newElement.style.background = '#fff3cd';
        newElement.style.border = '1px solid #ffeaa7';

        lastSection.insertBefore(newElement, pipe.nextElementSibling);
        insertedElements.push(newElement);
      };

      window.removeInserted = function () {
        insertedElements.forEach((el) => el.remove());
        insertedElements = [];
      };

      window.testCurrentConnection = function () {
        const lastSection = document.querySelector('section:last-of-type');
        const input = lastSection.querySelector('input');
        input.value = `Testing at ${new Date().toLocaleTimeString()}`;
      };

      // Script collapse/expand and re-execution functionality
      function initializeScriptInteractions() {
        document.querySelectorAll('script[type="hash-module"]').forEach((script) => {
          script.addEventListener('click', (e) => {
            const rect = script.getBoundingClientRect();
            const headerHeight = 40;
            const runButtonArea = { x: rect.width - 80, y: 40, width: 80, height: 30 };

            // Check if clicking on the run button area (::after pseudo-element)
            if (e.offsetX >= runButtonArea.x && e.offsetY <= runButtonArea.y) {
              executeScript(script);
              e.preventDefault();
              e.stopPropagation();
              return;
            }

            // Check if clicking on the header area for collapse/expand
            if (e.offsetY <= headerHeight) {
              script.classList.toggle('collapsed');
              e.preventDefault();
              e.stopPropagation();
            }
          });

          // Prevent text selection when clicking header
          script.addEventListener('selectstart', (e) => {
            const rect = script.getBoundingClientRect();
            const headerHeight = 40;

            if (e.offsetY <= headerHeight) {
              e.preventDefault();
            }
          });
        });
      }

      // Execute a script manually
      async function executeScript(scriptElement) {
        if (scriptElement.classList.contains('running')) return;

        scriptElement.classList.add('running');

        try {
          // Find the previous element to use as input (if any)
          let inputValue = undefined;
          let previousElement = scriptElement.previousElementSibling;

          // Skip over folk-pipe elements to find the actual data source
          while (previousElement && previousElement.tagName === 'FOLK-PIPE') {
            previousElement = previousElement.previousElementSibling;
          }

          // If there's a previous element but no pipe, this might be a data source script
          // For data source scripts, we can pass a trigger value
          if (!previousElement || previousElement.tagName !== 'FOLK-PIPE') {
            inputValue = Date.now(); // Trigger value for data source scripts
          }

          // Dispatch an input event to trigger the pipe system
          scriptElement.dispatchEvent(new Event('input', { bubbles: true }));

          // Give a brief visual feedback
          setTimeout(() => {
            scriptElement.classList.remove('running');
          }, 500);
        } catch (error) {
          console.error('Error executing script:', error);
          scriptElement.classList.remove('running');
        }
      }

      // Initialize script interactions after DOM is loaded
      initializeScriptInteractions();

      // Generate random data function
      window.generateRandomData = function () {
        const button = document.querySelector('button[onclick="generateRandomData()"]');
        button.textContent = 'Generating...';
        button.dispatchEvent(new Event('click'));

        setTimeout(() => {
          button.textContent = 'Generate Random Data';
        }, 100);
      };
    </script>
  </body>
</html>
